# 照片尺寸和方向问题复盘

**日期**: 2025-10-23  
**问题**: 瀑布流布局使用固定宽高比,导致照片显示比例不正确

---

## 问题现象

1. 瀑布流模式下,所有照片都使用模拟的固定宽高比(1.5、0.67、1)
2. 实际应该是竖图的照片显示为横图,反之亦然
3. 前端控制台显示大量"⚠️ 没有宽高数据,使用模拟值"警告

## 根本原因

### 原因1: 数据库字段缺失历史数据

- `width`、`height`、`orientation` 字段是开发中新增的
- 历史照片在字段添加时只有默认值(NULL或1)
- 没有真实的尺寸和方向数据

### 原因2: 上传代码Bug

**错误逻辑** (已修复):
```javascript
// 问题代码:总是强制设置orientation=1
const userRotation = req.body.rotation ? parseInt(req.body.rotation) : 0;
let orientationValue = 1; // ❌ 默认值1会覆盖原图EXIF
if (userRotation === 90) orientationValue = 6;
// ...
await sharp(req.file.buffer)
  .withMetadata({ orientation: orientationValue }) // 强制覆盖
  .toFile(filePath);
```

**问题**: 如果用户上传时没有手动旋转(rotation=0),代码会设置`orientation=1`,覆盖了原图本身的EXIF Orientation信息(可能是6/8等)。

## 解决方案

### 1. 修复上传逻辑

**正确逻辑**:
```javascript
// 修复后的代码
const userRotation = req.body.rotation ? parseInt(req.body.rotation) : 0;

let orientationValue = null;
if (userRotation > 0) {
  // ✅ 用户手动旋转了,设置对应的orientation
  if (userRotation === 90) orientationValue = 6;
  else if (userRotation === 180) orientationValue = 3;
  else if (userRotation === 270) orientationValue = 8;
} else {
  // ✅ 用户没有旋转,读取并保留原图的EXIF orientation
  const originalMetadata = await sharp(req.file.buffer).metadata();
  orientationValue = originalMetadata.orientation || 1;
}

await sharp(req.file.buffer)
  .withMetadata({ orientation: orientationValue }) // 保留或设置
  .toFile(filePath);

// ✅ 读取实际物理尺寸
const metadata = await sharp(filePath).metadata();
imageWidth = metadata.width;
imageHeight = metadata.height;
imageOrientation = orientationValue;

// ✅ 存入数据库
INSERT INTO photos (..., width, height, orientation, ...)
VALUES (..., imageWidth, imageHeight, imageOrientation, ...);
```

**关键点**:
- 区分"用户旋转"和"原图EXIF"
- 用户没有操作时,完全保留原图信息
- 存储原始物理尺寸(不考虑旋转)
- 存储EXIF Orientation值(1/3/6/8)

### 2. 批量修复历史数据

创建修复脚本:
```javascript
// scripts/fix-photo-dimensions.js
const sharp = require('sharp');
const sqlite3 = require('better-sqlite3');

async function updateAllPhotos() {
  const db = sqlite3('data/filmtrip.db');
  const photos = db.prepare('SELECT id, filename FROM photos WHERE filename IS NOT NULL').all();
  
  for (const photo of photos) {
    const filePath = path.join(__dirname, '../uploads', photo.filename);
    if (fs.existsSync(filePath)) {
      const metadata = await sharp(filePath).metadata();
      db.prepare('UPDATE photos SET width = ?, height = ?, orientation = ? WHERE id = ?')
        .run(metadata.width, metadata.height, metadata.orientation || 1, photo.id);
    }
  }
  db.close();
}
```

**执行结果**:
```
找到 8 张照片
✓ f52f5fbb-5bed-424d-8d55-05bd71736ca8_001.png: 1x1, orientation=1
✓ c180f5c5-5118-46fc-b3fc-02b231e46ced_002.JPG: 3637x2433, orientation=1
✓ 98e663c6-ebcb-4f80-bf66-044e252c6477_003.JPG: 3637x2433, orientation=8
✓ 8a173d75-0b7c-4321-b912-dde4ecf26117_001.JPG: 7008x4672, orientation=3
✓ 3a97cb4a-d1a9-4f36-b77e-271ab8285144_001.JPG: 3601x2433, orientation=8
✓ 733a6630-3f4d-4f7d-b479-8fb8bc9f8ad8_002.JPG: 3601x2433, orientation=1
✓ dca9619d-a280-477f-bad2-309113c6d5ac_002.JPG: 7008x4672, orientation=8
✓ c1b75a05-131a-46f2-affd-fc26ec36338c_004.JPG: 7008x4672, orientation=8
完成! 成功更新 8/8 张照片
```

### 3. 前端动态计算

**瀑布流布局**:
```javascript
// 根据orientation判断是否需要互换宽高
const needsSwap = photo.orientation === 6 || photo.orientation === 8;
const displayWidth = needsSwap ? photo.height : photo.width;
const displayHeight = needsSwap ? photo.width : photo.height;
const aspectRatio = displayWidth / displayHeight;

// 使用真实宽高比计算布局
const imageHeight = columnWidth / aspectRatio;
```

**PhotoPreview组件**:
```javascript
// 初始化时根据orientation调整尺寸估算
let w = photo?.width;
let h = photo?.height;
const orientation = photo?.orientation || 1;

if (w && h) {
  const needsSwap = orientation === 6 || orientation === 8;
  if (needsSwap) {
    [w, h] = [h, w]; // 互换宽高得到显示尺寸
  }
  setImageDimensions({ width: w, height: h });
}
```

## EXIF Orientation 值含义

| 值 | 含义 | 说明 |
|----|------|------|
| 1 | 正常 | 0度,不需要旋转 |
| 3 | 旋转180° | 上下颠倒 |
| 6 | 顺时针旋转90° | 竖图存储为横图,需要右转 |
| 8 | 逆时针旋转90° | 横图存储为竖图,需要左转 |

**关键理解**:
- 数据库存储**物理尺寸**(像素实际排列)
- EXIF Orientation描述**如何旋转来正确显示**
- 前端需要根据orientation计算**显示尺寸**

**示例**:
```
文件物理尺寸: 7008(宽) x 4672(高) - 横向排列
EXIF Orientation: 8 (逆时针90度)
显示尺寸: 4672(宽) x 7008(高) - 竖图
```

## 验证测试

### 测试用例

| 照片ID | 物理尺寸 | Orientation | 显示尺寸 | 显示方向 |
|--------|----------|-------------|----------|----------|
| 98e663c6 | 3637x2433 | 8 | 2433x3637 | 竖图 ✅ |
| 8a173d75 | 7008x4672 | 3 | 7008x4672 | 横图 ✅ |
| 3a97cb4a | 3601x2433 | 8 | 2433x3601 | 竖图 ✅ |
| 733a6630 | 3601x2433 | 1 | 3601x2433 | 横图 ✅ |
| dca9619d | 7008x4672 | 8 | 4672x7008 | 竖图 ✅ |
| c1b75a05 | 7008x4672 | 8 | 4672x7008 | 竖图 ✅ |

### 验证步骤

1. ✅ 刷新前端页面
2. ✅ 切换到瀑布流模式
3. ✅ 检查所有照片宽高比正确
4. ✅ 点击预览,单张显示也正确
5. ✅ 控制台无"没有宽高数据"警告

## 预防措施

### 1. 代码层面

**上传时自动处理**:
- ✅ 读取原图EXIF Orientation
- ✅ 保存原图时正确设置EXIF
- ✅ 读取实际物理尺寸
- ✅ 存入数据库(width/height/orientation)

**前端容错**:
- ✅ 优先使用真实数据
- ✅ 缺失时使用模拟值(fallback)
- ✅ 控制台警告提示异常

### 2. 数据层面

**数据库约束**:
```sql
ALTER TABLE photos 
  ADD COLUMN width INTEGER,
  ADD COLUMN height INTEGER,
  ADD COLUMN orientation INTEGER DEFAULT 1;
```

**默认值**:
- width/height: NULL (便于识别缺失数据)
- orientation: 1 (正常朝向)

### 3. 运维层面

**定期检查**:
```bash
# 检查是否有照片缺少尺寸数据
sqlite3 data/filmtrip.db "SELECT COUNT(*) FROM photos WHERE width IS NULL OR height IS NULL;"
```

**批量修复**:
```bash
# 如果发现问题,运行修复脚本
cd backend && node scripts/fix-photo-dimensions.js
```

## 经验教训

### ✅ 做对的事

1. **保留原始数据**: 不修改原图的EXIF信息
2. **分离物理尺寸和显示尺寸**: 数据库存物理尺寸,前端动态计算显示尺寸
3. **用户操作优先**: 只有用户手动旋转时才覆盖EXIF
4. **完整的数据修复**: 批量更新历史数据,确保数据完整性

### ❌ 避免的错误

1. ~~强制覆盖EXIF Orientation~~ → 保留原图EXIF
2. ~~假设所有照片都有默认方向~~ → 读取实际EXIF
3. ~~前端硬编码宽高比~~ → 使用真实数据动态计算
4. ~~忽略历史数据问题~~ → 主动修复数据完整性

## 相关文档

- [图片旋转实现最佳实践与问题复盘](./图片旋转实现最佳实践与问题复盘.md)
- [前端设计规范](../前端设计规范.md)
- [数据库设计](../数据库设计.md)

---

**总结**: 这个问题的核心是**数据完整性**和**EXIF处理逻辑**。修复后,系统完全尊重原图的EXIF信息,前端根据orientation动态计算显示尺寸,实现了正确的瀑布流布局。

