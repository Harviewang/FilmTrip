# åˆ—è¡¨æ¨¡å¼æ‡’åŠ è½½é—®é¢˜ - å®Œæ•´ä»£ç æ¸…å•

## é—®é¢˜æè¿°
åˆ—è¡¨æ¨¡å¼ï¼ˆå¹³é“ºæ¨¡å¼ï¼‰ä½¿ç”¨ `LazyImage` ç»„ä»¶ï¼Œä½†æ‡’åŠ è½½ä¸ç”Ÿæ•ˆï¼Œæ‰€æœ‰å›¾ç‰‡åœ¨é¡µé¢åŠ è½½æ—¶ç«‹å³å…¨éƒ¨åŠ è½½ã€‚

## å®Œæ•´ä»£ç æ¸…å•

### 1. Gallery ç»„ä»¶ - åˆ—è¡¨æ¨¡å¼æ¸²æŸ“
**æ–‡ä»¶**: `frontend/src/pages/Gallery/index.jsx`

#### 1.1 åˆ—è¡¨æ¨¡å¼çš„ Grid å¸ƒå±€ï¼ˆç¬¬847-851è¡Œï¼‰
```javascript
{(viewMode === 'list' || !WATERFALL_ENABLED) ? (
  // å›ºå®šç½‘æ ¼ï¼šä¸€è¡Œ4ä¸ªï¼Œç»Ÿä¸€å®½é«˜
  <div className="grid gap-6 sm:gap-8 grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-4">
    {photos.map((photo) => renderPhotoCard(photo))}
  </div>
) : (
  // ç€‘å¸ƒæµæ¨¡å¼...
)}
```

#### 1.2 renderPhotoCard å‡½æ•° - åˆ—è¡¨æ¨¡å¼éƒ¨åˆ†ï¼ˆç¬¬559-667è¡Œï¼‰
```javascript
const renderPhotoCard = (photo, isRandomMode = false, isMasonry = false) => {
  const isAdmin = (() => {
    try { const u = JSON.parse(localStorage.getItem('user')); return u && u.username === 'admin'; } catch (e) { return false; }
  })();
  
  // éšæœºæ¨¡å¼ä¸‹çš„ç…§ç‰‡å·²ç»ç”±åç«¯è¿‡æ»¤ï¼Œä¸éœ€è¦å†æ¬¡æ£€æŸ¥ä¿æŠ¤çŠ¶æ€
  if (isRandomMode) {
    const randomContent = (
      <div className={'relative w-full overflow-hidden rounded-lg'} style={{ paddingTop: '75%' /* 4:3 aspect ratio */ }}>
        <div className="absolute inset-0">
          <LazyImage
            src={(photo.size1024 || photo.thumbnail) ? `${API_CONFIG.BASE_URL}${photo.size1024 || photo.thumbnail}?v=${stableTimestamp}` : null}
            alt={photo.title || 'ç…§ç‰‡'}
            className={`transition-transform duration-300 group-hover:scale-110 w-full h-full object-cover`}
            onClick={(e) => handlePhotoClick(photo, e)}
            onMouseDown={(e) => handlePhotoMouseDown(photo, e)}
            onMouseMove={(e) => handlePhotoMouseMove(photo, e)}
            autoOrientation={true}
            lazyOptions={{
              rootMargin: '50px',
              threshold: 0.05
            }}
          />
        </div>
      </div>
    );
    
    if (isMasonry) {
      return randomContent;
    }
    
    return (
      <AdaptiveCard 
        key={photo.id} 
        className="h-full group photo-card cursor-pointer"
        hover={true}
        shadow={'default'}
      >
        {randomContent}
      </AdaptiveCard>
    );
  }
  
  // æ™®é€šæ¨¡å¼ï¼šæ£€æŸ¥ä¿æŠ¤çŠ¶æ€
  const effectiveProtection = !!(photo && photo._raw && photo._raw.effective_protection);
  const isProtectedForViewer = effectiveProtection && !isAdmin;
  
  // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„å›¾ç‰‡URL
  const hasValidImageUrl = photo.size1024 || photo.thumbnail;
  
  const content = (
    <div className={'relative w-full overflow-hidden rounded-lg'} style={{ paddingTop: '75%' /* 4:3 aspect ratio */ }}>
      <div className="absolute inset-0">
        {isProtectedForViewer || !hasValidImageUrl ? (
          // éç®¡ç†å‘˜ç”¨æˆ·æˆ–æ²¡æœ‰æœ‰æ•ˆURLæ—¶æ˜¾ç¤ºé”å›¾æ ‡
          <div
            className={`w-full h-full flex items-center justify-center bg-gray-100 text-gray-500 relative`}
            title={isProtectedForViewer ? "å·²åŠ å¯†ï¼šæœªç™»å½•ç”¨æˆ·ä¸å¯æŸ¥çœ‹è¯¦æƒ…" : "å›¾ç‰‡ä¸å¯ç”¨"}
          >
            <div className="flex flex-col items-center">
              <div className="text-3xl mb-2">ğŸ”’</div>
              <div className="text-xs">{isProtectedForViewer ? "è¯¥ç…§ç‰‡æ¶‰åŠéšç§æˆ–ä»–äººè‚–åƒï¼Œå·²è¢«ç®¡ç†å‘˜åŠ å¯†" : "å›¾ç‰‡ä¸å¯ç”¨"}</div>
            </div>
          </div>
        ) : (
          // æ™®é€šç”¨æˆ·æˆ–ç®¡ç†å‘˜å¯ä»¥æŸ¥çœ‹çš„ç…§ç‰‡ - è¿™é‡Œæ˜¯åˆ—è¡¨æ¨¡å¼ä½¿ç”¨çš„ LazyImage
          <LazyImage
            src={`${API_CONFIG.BASE_URL}${photo.size1024 || photo.thumbnail}?v=${stableTimestamp}`}
            alt={photo.title || 'ç…§ç‰‡'}
            className={`transition-transform duration-300 group-hover:scale-110 w-full h-full object-cover`}
            onClick={(e) => handlePhotoClick(photo, e)}
            onMouseDown={(e) => handlePhotoMouseDown(photo, e)}
            onMouseMove={(e) => handlePhotoMouseMove(photo, e)}
            autoOrientation={true}
            lazyOptions={{
              rootMargin: '0px',
              threshold: 0.01
            }}
          />
        )}
        {/* ç®¡ç†å‘˜è§†å›¾ï¼šåŠ å¯†åˆ™å¸¸æ˜¾é”å›¾æ ‡ï¼ˆæ— æ–‡æ¡ˆï¼‰ */}
        {!isProtectedForViewer && effectiveProtection && (
          <div className="absolute top-2 left-2 bg-black/60 text-white text-xs px-2 py-1 rounded" title="åŠ å¯†">
            ğŸ”’
          </div>
        )}
      </div>
    </div>
  );
  
  if (isMasonry) {
    return (
      <div className={`masonry-content relative w-full h-full overflow-hidden rounded-lg bg-gray-100 shadow-sm hover:shadow-lg transition-shadow ${isProtectedForViewer ? 'cursor-not-allowed' : 'cursor-pointer'}`} onClick={(e)=>{ if (isProtectedForViewer) return; handlePhotoClick(photo, e); }}>
        {content}
      </div>
    );
  }
  
  return (
    <AdaptiveCard 
      key={photo.id} 
      className={`h-full group photo-card overflow-hidden rounded-lg bg-gray-100 shadow-sm hover:shadow-lg transition-shadow ${isProtectedForViewer ? 'cursor-not-allowed' : 'cursor-pointer'}`}
      hover={false}
      shadow={undefined}
    >
      {content}
    </AdaptiveCard>
  );
};
```

**å…³é”®ç‚¹**:
- åˆ—è¡¨æ¨¡å¼è°ƒç”¨ `renderPhotoCard(photo)`ï¼Œä¸ä¼  `isMasonry` å‚æ•°ï¼ˆé»˜è®¤ä¸º `false`ï¼‰
- ä½¿ç”¨ `LazyImage` ç»„ä»¶ï¼Œé…ç½® `rootMargin: '0px'`, `threshold: 0.01`
- å¤–å±‚ div ä½¿ç”¨ `paddingTop: '75%'` åˆ›å»º 4:3 å®½é«˜æ¯”
- `ref` ç»‘å®šåœ¨ LazyImage å†…éƒ¨çš„å¤–å±‚ div ä¸Š

### 2. LazyImage ç»„ä»¶
**æ–‡ä»¶**: `frontend/src/components/LazyImage.jsx`

```javascript
import React, { useState, useCallback, useEffect } from 'react';
import { useLazyImage } from '../hooks/useLazyLoading';
import { simpleDetectImageNeedsRotation, getImageTransform } from '../utils/imageOrientation';

/**
 * æ‡’åŠ è½½å›¾ç‰‡ç»„ä»¶
 * @param {Object} props
 * @param {string} props.src å›¾ç‰‡æºåœ°å€
 * @param {string} props.alt å›¾ç‰‡altå±æ€§
 * @param {string} props.className CSSç±»å
 * @param {string} props.placeholder å ä½ç¬¦å›¾ç‰‡
 * @param {Function} props.onClick ç‚¹å‡»äº‹ä»¶
 * @param {Object} props.lazyOptions æ‡’åŠ è½½é€‰é¡¹
 * @param {boolean} props.autoOrientation æ˜¯å¦è‡ªåŠ¨å¤„ç†å›¾ç‰‡æ–¹å‘
 * @returns {JSX.Element}
 */
const LazyImage = ({
  src,
  alt = '',
  className = '',
  placeholder = null,
  onClick,
  lazyOptions = {},
  autoOrientation = true,
  ...props
}) => {
  const { ref, imageSrc, isLoading, hasError, onLoad, onError, retry } = useLazyImage(
    src,
    placeholder,
    lazyOptions
  );
  
  const [imageLoaded, setImageLoaded] = useState(false);
  const [needsRotation, setNeedsRotation] = useState(false);
  const [imageRotation, setImageRotation] = useState(0);

  const handleLoad = useCallback((e) => {
    setImageLoaded(true);
    onLoad(e);
    
    // ç®€åŒ–å›¾ç‰‡æ–¹å‘å¤„ç†ï¼šSVGå›¾ç‰‡ä¸éœ€è¦æ—‹è½¬
    if (autoOrientation && imageSrc && !imageSrc.includes('.svg') && !imageSrc.includes('image/svg')) {
      simpleDetectImageNeedsRotation(imageSrc).then((needs) => {
        setNeedsRotation(needs);
        if (needs) {
          // å¦‚æœæ£€æµ‹åˆ°éœ€è¦æ—‹è½¬ï¼Œåº”ç”¨90åº¦æ—‹è½¬
          setImageRotation(90);
        } else {
          setImageRotation(0);
        }
      }).catch(() => {
        // æ£€æµ‹å¤±è´¥æ—¶ä¸æ—‹è½¬
        setNeedsRotation(false);
        setImageRotation(0);
      });
    } else {
      // SVGæˆ–æ£€æµ‹å¤±è´¥æ—¶ä¸æ—‹è½¬
      setNeedsRotation(false);
      setImageRotation(0);
    }
  }, [onLoad, autoOrientation, imageSrc]);

  const handleError = useCallback((e) => {
    console.error('å›¾ç‰‡åŠ è½½å¤±è´¥:', src, e);
    onError(e);
  }, [onError, src]);

  const handleClick = useCallback((e) => {
    if (onClick && !isLoading && !hasError) {
      onClick(e);
    }
  }, [onClick, isLoading, hasError]);

  // æ„å»ºCSSç±»å
  const imageClassName = [
    className,
    autoOrientation ? 'image-orientation-auto' : '',
    onClick ? 'cursor-pointer' : '',
    'transition-all duration-300'
  ].filter(Boolean).join(' ');

  // å›¾ç‰‡æ ·å¼å¯¹è±¡
  const imageStyle = {
    width: '100%',
    height: '100%',
    opacity: imageLoaded ? 1 : 0,
    transition: 'opacity 0.3s ease-in-out, transform 0.3s ease-in-out',
    imageOrientation: autoOrientation ? 'from-image' : 'none',
    objectFit: className && className.includes('gallery-photo') ? 'contain' : 'cover',
    transform: autoOrientation && imageRotation > 0 ? `rotate(${imageRotation}deg)` : 'none',
    transformOrigin: 'center center'
  };

  return (
    <div ref={ref} className="relative w-full h-full">
      {/* éª¨æ¶å±å ä½ç¬¦ - åœ¨å›¾ç‰‡æœªåŠ è½½æˆ–æ­£åœ¨åŠ è½½æ—¶æ˜¾ç¤º */}
      {(!imageSrc || isLoading || !imageLoaded) && !hasError && (
        <div className="absolute inset-0 bg-gradient-to-r from-gray-200 via-gray-300 to-gray-200 rounded-lg animate-pulse">
          <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white to-transparent opacity-50 animate-shimmer" />
        </div>
      )}
      
      {/* é”™è¯¯å ä½ç¬¦ */}
      {hasError && (
        <div className="absolute inset-0 bg-gray-200 flex items-center justify-center rounded-lg">
          <div className="text-center text-gray-400">
            <svg className="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
            </svg>
            <p className="text-xs mb-2">åŠ è½½å¤±è´¥</p>
            <button 
              onClick={(e) => {
                e.stopPropagation();
                retry();
              }}
              className="text-xs bg-blue-500 text-white px-2 py-1 rounded hover:bg-blue-600 transition-colors"
            >
              é‡è¯•
            </button>
          </div>
        </div>
      )}
      
      {/* å®é™…å›¾ç‰‡ */}
      {imageSrc && !hasError && (
        <img
          src={imageSrc}
          alt={alt}
          className={imageClassName}
          onClick={handleClick}
          onLoad={handleLoad}
          onError={handleError}
          onDragStart={(e) => e.preventDefault()} // ç¦ç”¨å›¾ç‰‡æ‹–æ‹½
          draggable={false} // ç¦ç”¨æ‹–æ‹½å±æ€§
          style={imageStyle}
          {...props}
        />
      )}
      
      {/* åŠ è½½æŒ‡ç¤ºå™¨ - æ›´æ˜æ˜¾çš„åŠ¨ç”» */}
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-20 rounded-lg">
          <div className="flex flex-col items-center space-y-2">
            <div className="w-8 h-8 border-3 border-white border-t-transparent rounded-full animate-spin" />
            <span className="text-white text-xs font-medium bg-black bg-opacity-50 px-2 py-1 rounded">åŠ è½½ä¸­...</span>
          </div>
        </div>
      )}
    </div>
  );
};

export default LazyImage;
```

**å…³é”®ç‚¹**:
- `ref` ç»‘å®šåœ¨å¤–å±‚ `<div>` ä¸Šï¼ˆç¬¬95è¡Œï¼‰
- ä½¿ç”¨ `useLazyImage` hook ç®¡ç†æ‡’åŠ è½½çŠ¶æ€
- åªæœ‰ `imageSrc` ä¸ä¸º null æ—¶æ‰æ¸²æŸ“ `<img>`ï¼ˆç¬¬125è¡Œï¼‰
- `imageSrc` ç”± `useLazyImage` hook çš„ `hasLoaded` çŠ¶æ€æ§åˆ¶

### 3. useLazyLoading Hook
**æ–‡ä»¶**: `frontend/src/hooks/useLazyLoading.js`

```javascript
import { useState, useEffect, useRef, useCallback } from 'react';

/**
 * æ‡’åŠ è½½Hook
 * @param {Object} options é…ç½®é€‰é¡¹
 * @param {string} options.rootMargin Intersection Observerçš„rootMargin
 * @param {number} options.threshold Intersection Observerçš„threshold
 * @returns {Object} { ref, isIntersecting, hasLoaded }
 */
export const useLazyLoading = (options = {}) => {
  const {
    rootMargin = '50px', // å‡å°‘é¢„åŠ è½½è·ç¦»ï¼Œç¡®ä¿çœŸæ­£çš„æ‡’åŠ è½½
    threshold = 0.1,
    root = null // å…è®¸è‡ªå®šä¹‰æ ¹å…ƒç´ 
  } = options;

  const [isIntersecting, setIsIntersecting] = useState(false);
  const [hasLoaded, setHasLoaded] = useState(false);
  const ref = useRef(null);
  const observerRef = useRef(null);
  const timeoutRef = useRef(null);

  useEffect(() => {
    const element = ref.current;
    if (!element) return;

    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    if (!window.IntersectionObserver) {
      // é™çº§æ–¹æ¡ˆï¼šç›´æ¥åŠ è½½
      setIsIntersecting(true);
      setHasLoaded(true);
      return;
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        console.log('IntersectionObserver triggered:', {
          isIntersecting: entry.isIntersecting,
          intersectionRatio: entry.intersectionRatio,
          boundingClientRect: entry.boundingClientRect,
          rootBounds: entry.rootBounds
        });
        if (entry.isIntersecting) {
          // æ·»åŠ å°å»¶è¿Ÿç¡®ä¿ç»„ä»¶å·²å®Œå…¨æŒ‚è½½
          timeoutRef.current = setTimeout(() => {
            setIsIntersecting(true);
            setHasLoaded(true);
            // ç«‹å³åœæ­¢è§‚å¯Ÿä»¥æå‡æ€§èƒ½
            observer.unobserve(element);
          }, 100);
        }
      },
      {
        root,
        rootMargin,
        threshold
      }
    );

    observerRef.current = observer;
    observer.observe(element);

    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
        observerRef.current = null;
      }
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
    };
  }, [rootMargin, threshold, root]);

  return { ref, isIntersecting, hasLoaded };
};
```

**å…³é”®ç‚¹**:
- ä½¿ç”¨ `IntersectionObserver` æ£€æµ‹å…ƒç´ æ˜¯å¦è¿›å…¥è§†å£
- å½“ `entry.isIntersecting` ä¸º `true` æ—¶ï¼Œè®¾ç½® `hasLoaded = true`
- æœ‰è°ƒè¯•æ—¥å¿—è¾“å‡ºï¼ˆç¬¬37-42è¡Œï¼‰
- `ref` éœ€è¦ç»‘å®šåˆ°è¦è§‚å¯Ÿçš„ DOM å…ƒç´ ä¸Š

### 4. useLazyImage Hook
**æ–‡ä»¶**: `frontend/src/hooks/useLazyLoading.js`ï¼ˆç¬¬85-188è¡Œï¼‰

```javascript
/**
 * æ‡’åŠ è½½å›¾ç‰‡ç»„ä»¶Hook
 * @param {string} src å›¾ç‰‡æºåœ°å€
 * @param {string} placeholder å ä½ç¬¦åœ°å€
 * @param {Object} options æ‡’åŠ è½½é€‰é¡¹
 * @returns {Object} { ref, imageSrc, isLoading, hasError, onLoad, onError }
 */
export const useLazyImage = (src, placeholder = null, options = {}) => {
  const { ref, hasLoaded } = useLazyLoading(options);
  const [imageSrc, setImageSrc] = useState(null); // åˆå§‹ä¸ºnullï¼Œä¸æ˜¾ç¤ºä»»ä½•å›¾ç‰‡
  const [isLoading, setIsLoading] = useState(false);
  const [hasError, setHasError] = useState(false);
  const imageRef = useRef(null);
  const retryCountRef = useRef(0);
  const maxRetries = 2;

  useEffect(() => {
    if (!hasLoaded || !src) return;

    setIsLoading(true);
    setHasError(false);
    retryCountRef.current = 0;

    const loadImage = () => {
      const img = new Image();
      imageRef.current = img;
      
      img.onload = () => {
        // æ£€æŸ¥ç»„ä»¶æ˜¯å¦ä»ç„¶æŒ‚è½½
        if (imageRef.current === img) {
          setImageSrc(src);
          setIsLoading(false);
          setHasError(false);
        }
      };
      
      img.onerror = () => {
        if (imageRef.current === img) {
          retryCountRef.current++;
          if (retryCountRef.current < maxRetries) {
            // å»¶è¿Ÿé‡è¯•
            setTimeout(loadImage, 1000 * retryCountRef.current);
          } else {
            setHasError(true);
            setIsLoading(false);
          }
        }
      };
      
      img.src = src;
    };

    loadImage();

    return () => {
      // æ¸…ç†å›¾ç‰‡å¼•ç”¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
      if (imageRef.current) {
        imageRef.current.onload = null;
        imageRef.current.onerror = null;
        imageRef.current = null;
      }
    };
  }, [hasLoaded, src]);

  const onLoad = useCallback(() => {
    setIsLoading(false);
    setHasError(false);
  }, []);

  const onError = useCallback(() => {
    setHasError(true);
    setIsLoading(false);
  }, []);

  const retry = useCallback(() => {
    if (src && hasLoaded) {
      setHasError(false);
      setIsLoading(true);
      retryCountRef.current = 0;
      
      const img = new Image();
      imageRef.current = img;
      
      img.onload = () => {
        if (imageRef.current === img) {
          setImageSrc(src);
          setIsLoading(false);
        }
      };
      
      img.onerror = () => {
        if (imageRef.current === img) {
          setHasError(true);
          setIsLoading(false);
        }
      };
      
      img.src = src;
    }
  }, [src, hasLoaded]);

  return {
    ref,
    imageSrc,
    isLoading: isLoading && hasLoaded,
    hasError,
    onLoad,
    onError,
    retry
  };
};
```

**å…³é”®ç‚¹**:
- ä¾èµ– `hasLoaded` çŠ¶æ€ï¼ˆç¬¬94è¡Œï¼‰
- åªæœ‰ `hasLoaded && src` æ—¶æ‰åˆ›å»º Image å¯¹è±¡ï¼ˆç¬¬95è¡Œï¼‰
- å›¾ç‰‡åŠ è½½æˆåŠŸåè®¾ç½® `imageSrc` çŠ¶æ€ï¼ˆç¬¬108è¡Œï¼‰
- `imageSrc` åˆå§‹ä¸º `null`ï¼Œåªæœ‰åŠ è½½æˆåŠŸåæ‰è®¾ç½®

### 5. ç€‘å¸ƒæµæ¨¡å¼ï¼ˆå¯¹æ¯”å‚è€ƒ - å·¥ä½œæ­£å¸¸ï¼‰
**æ–‡ä»¶**: `frontend/src/pages/Gallery/index.jsx`
**ä½ç½®**: ç¬¬963-971è¡Œ

```javascript
<img
  src={(photo.size1024 || photo.thumbnail) ? `${API_CONFIG.BASE_URL}${photo.size1024 || photo.thumbnail}?v=${stableTimestamp}` : ''}
  alt={photo.title || 'ç…§ç‰‡'}
  className="w-full h-full object-cover select-none hover:opacity-95 transition-opacity"
  loading="lazy"
  onMouseDown={(e) => handlePhotoMouseDown(photo, e)}
  onMouseMove={(e) => handlePhotoMouseMove(photo, e)}
  draggable={false}
/>
```

**å…³é”®ç‚¹**:
- ä½¿ç”¨åŸç”Ÿ `<img loading="lazy" />`
- ç®€å•ã€å¯é ã€æ€§èƒ½å¥½
- ç”±æµè§ˆå™¨åŸç”Ÿå®ç°æ‡’åŠ è½½

## é—®é¢˜åˆ†æ

### æ•°æ®æµ
1. `Gallery` ç»„ä»¶æ¸²æŸ“ Grid å¸ƒå±€
2. `renderPhotoCard` å‡½æ•°ä¸ºæ¯ä¸ª photo åˆ›å»º `LazyImage` ç»„ä»¶
3. `LazyImage` ä½¿ç”¨ `useLazyImage` hook
4. `useLazyImage` ä½¿ç”¨ `useLazyLoading` hook
5. `useLazyLoading` ä½¿ç”¨ `IntersectionObserver` æ£€æµ‹å…ƒç´ æ˜¯å¦è¿›å…¥è§†å£
6. å½“ `entry.isIntersecting === true` æ—¶ï¼Œè®¾ç½® `hasLoaded = true`
7. `hasLoaded` å˜åŒ–è§¦å‘ `useLazyImage` çš„ `useEffect`ï¼ˆç¬¬94è¡Œï¼‰
8. åˆ›å»º `Image` å¯¹è±¡å¹¶è®¾ç½® `src`
9. å›¾ç‰‡åŠ è½½æˆåŠŸåè®¾ç½® `imageSrc` çŠ¶æ€
10. `LazyImage` ç»„ä»¶æ ¹æ® `imageSrc` æ¸²æŸ“ `<img>` æ ‡ç­¾

### å¯èƒ½çš„é—®é¢˜ç‚¹

1. **IntersectionObserver ç«‹å³è§¦å‘**
   - Grid å¸ƒå±€ä¸‹ï¼Œæ‰€æœ‰å¡ç‰‡éƒ½åœ¨ DOM ä¸­
   - å³ä½¿ä¸åœ¨è§†å£å†…ï¼ŒIntersectionObserver å¯èƒ½å› ä¸ºæŸäº›åŸå› ç«‹å³è§¦å‘
   - æ£€æŸ¥æ§åˆ¶å°æ—¥å¿—ï¼Œè§‚å¯Ÿæœ‰å¤šå°‘å…ƒç´ ç«‹å³è§¦å‘

2. **ref ç»‘å®šä½ç½®**
   - `ref` ç»‘å®šåœ¨å¤–å±‚ `<div>` ä¸Šï¼ˆLazyImage.jsx ç¬¬95è¡Œï¼‰
   - å¤–å±‚ div ä½¿ç”¨ `paddingTop: '75%'` åˆ›å»ºå›ºå®šå®½é«˜æ¯”
   - è¿™ä¸ª div å¯èƒ½è¿‡å¤§ï¼Œå¯¼è‡´ IntersectionObserver è®¤ä¸ºå®ƒåœ¨è§†å£å†…

3. **IntersectionObserver åˆå§‹åŒ–æ—¶æœº**
   - å¯èƒ½åœ¨ Grid å¸ƒå±€æ¸²æŸ“å®Œæˆåï¼Œæ‰€æœ‰å…ƒç´ éƒ½å·²ç»"å¯è§"
   - éœ€è¦å»¶è¿Ÿåˆå§‹åŒ–æˆ–æ›´ä¸¥æ ¼çš„å¯è§æ€§åˆ¤æ–­

4. **é…ç½®é—®é¢˜**
   - `rootMargin: '0px'` - æ— é¢„åŠ è½½è·ç¦»
   - `threshold: 0.01` - éœ€è¦è‡³å°‘ 1% çš„é¢ç§¯è¿›å…¥è§†å£
   - å¯èƒ½éœ€è¦æ›´ä¸¥æ ¼çš„é…ç½®

## è°ƒè¯•æ­¥éª¤

1. **æ£€æŸ¥ IntersectionObserver è§¦å‘æƒ…å†µ**
   - æ‰“å¼€æµè§ˆå™¨æ§åˆ¶å°
   - æŸ¥çœ‹ "IntersectionObserver triggered" æ—¥å¿—
   - è§‚å¯Ÿæœ‰å¤šå°‘å…ƒç´ ç«‹å³è§¦å‘ï¼ˆ`isIntersecting: true`ï¼‰
   - æ£€æŸ¥å®ƒä»¬çš„ `boundingClientRect` ä½ç½®
   - æ£€æŸ¥ `rootBounds` çš„å€¼

2. **æ£€æŸ¥ Network æ ‡ç­¾**
   - æ‰“å¼€ Network æ ‡ç­¾ â†’ ç­›é€‰å›¾ç‰‡è¯·æ±‚
   - åˆ·æ–°é¡µé¢ï¼Œè§‚å¯Ÿå“ªäº›å›¾ç‰‡ç«‹å³åŠ è½½
   - æ»šåŠ¨é¡µé¢ï¼Œè§‚å¯Ÿæ˜¯å¦æŒ‰éœ€åŠ è½½

3. **æ£€æŸ¥å…ƒç´ ä½ç½®**
   - ä½¿ç”¨æµè§ˆå™¨ DevTools æ£€æŸ¥å¡ç‰‡å…ƒç´ 
   - ç¡®è®¤ä¸åœ¨è§†å£å†…çš„å¡ç‰‡æ˜¯å¦ä¹Ÿè¢«åŠ è½½
   - æ£€æŸ¥ `getBoundingClientRect()` è¿”å›å€¼

4. **æ£€æŸ¥çŠ¶æ€å˜åŒ–**
   - åœ¨ `useLazyLoading` çš„ `useEffect` ä¸­æ·»åŠ æ—¥å¿—
   - è§‚å¯Ÿ `hasLoaded` ä½•æ—¶å˜ä¸º `true`
   - åœ¨ `useLazyImage` çš„ `useEffect` ä¸­æ·»åŠ æ—¥å¿—
   - è§‚å¯Ÿå›¾ç‰‡ä½•æ—¶å¼€å§‹åŠ è½½

## ä¿®å¤å»ºè®®

### æ–¹æ¡ˆ1: ä½¿ç”¨åŸç”Ÿæ‡’åŠ è½½ï¼ˆæ¨èï¼‰
æ›¿æ¢ `LazyImage` ä¸ºåŸç”Ÿ `<img loading="lazy" />`ï¼Œä¸ç€‘å¸ƒæµæ¨¡å¼ä¿æŒä¸€è‡´ã€‚

### æ–¹æ¡ˆ2: ä¿®å¤ IntersectionObserver é…ç½®
è°ƒæ•´ `rootMargin` å’Œ `threshold`ï¼Œæˆ–æ·»åŠ åˆå§‹åŒ–æ£€æŸ¥ã€‚

### æ–¹æ¡ˆ3: ä¿®æ”¹ IntersectionObserver å®ç°
æ·»åŠ åˆå§‹åŒ–æ£€æŸ¥ï¼Œå»¶è¿Ÿè§‚å¯Ÿï¼Œæˆ–åœ¨é¦–æ¬¡æ¸²æŸ“æ—¶æ£€æŸ¥å…ƒç´ ä½ç½®ã€‚

### æ–¹æ¡ˆ4: å®ç°è™šæ‹Ÿæ»šåŠ¨
å¦‚æœå›¾ç‰‡æ•°é‡å¾ˆå¤šï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼ˆå¦‚ `react-window`ï¼‰ã€‚




