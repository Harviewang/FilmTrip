# 地图中文地址增强 - 完整实现方案

## 需求背景

用户需要在FilmTrip中实现地图中文地点增强，主要包括：
1. 地图选点自动解析为5级中文地址（国家/省/市/区/街道〈township〉）
2. 上传/编辑表单支持地图选点并自动回填地址字段
3. 照片预览页点击省市区字段显示迷你地图

## 核心目标

- **地图选点 → 五级中文地址**：通过地图选点获取 `country/province/city/district/township` 与 `latitude/longitude`。
- **地址回填**：上传 / 编辑流程仅支持地图选点，解析后回填字段，展示时拼成完整中文地址。
- **按需展示**：照片预览页点击地点字段时再加载迷你地图，并在 `/map` 页面按坐标打点。
- **自动翻译**：国外地址在必要时自动转换为中文。
- **统一接口**：优先使用 MapTiler API，预留 Geomaply 作为备选方案。

## 非目标（当前阶段）

- 底图中文化（MapLibre 样式切换）
- 地图点聚合 / 聚类可视化
- 批量自动补全历史数据（计划通过工具逐步完成）
- 多语言底图切换、分享导出等增值能力

## 方案选型

### 方案选择

- **主方案**：MapTiler API（全球覆盖、统一接口、包含 `country_code`，便于翻译和字段映射）。
- **备选方案**：Geomaply（提供免费瓦片与地址解析，可作为 MapTiler 降级或离线补充，当前阶段仅预留文档说明，暂不接入）。
- **非目标**：高德 / 腾讯等国内 API（需判断国内外、接口不统一，暂不使用）。

## 技术实现

### 1. MapTiler数据结构

```javascript
// API返回的context数组（倒序：从详细到宏观）
{
  "features": [{
    "context": [
      { "id": "country.214", "text": "中国", "country_code": "cn" },
      { "id": "subregion.457", "text": "广东省", "country_code": "cn" },
      { "id": "county.3556", "text": "深圳市", "country_code": "cn", "designation": "city" },
      { "id": "joint_municipality.10486", "text": "南山区", "country_code": "cn" },
      { "id": "municipality.158530", "text": "粤海街道", "designation": "suburb" }
    ],
    "place_name": "深大北天橋, 518060 粤海街道, 中国"
  }]
}
```

### 2. 层级映射逻辑

#### 场景A：中国多层结构（深圳）
```
context层级：
- subregion → province（广东省）
- county → city（深圳市）
- joint_municipality → district（南山区）
- municipality.suburb → township（粤海街道）

最终映射：
country = "中国"
province = "广东省"
city = "深圳市"
district = "南山区"
township = "粤海街道"
```

#### 场景B：中国直辖市（北京）
```
context层级：
- subregion → province（北京市）
- joint_municipality → city（东城区）
- municipality.suburb → township（东华门街道）

最终映射：
country = "中国"
province = "北京市"
city = "东城区"
district = ""
township = "东华门街道"
```

#### 场景C：国外结构（纽约）
```
context层级：
- country.1224 → country（United States）
- region.3155 → province（New York state）
- subregion.4855 → city（City of New York）
- joint_municipality.21086 → district（Manhattan）

最终映射（翻译后）：
country = "美国"（翻译）
province = "纽约州"（翻译）
city = ""
district = "Manhattan"
township = ""
```

### 3. 核心实现代码

#### 3.1 解析MapTiler的context

```javascript
function parseMapTilerContext(context) {
  const tempData = {};
  
  // 遍历context收集数据
  context.forEach(item => {
    const text = item.text || '';
    const id = item.id || '';
    const designation = item.place_designation || '';
    
    if (id.includes('country.') || designation === 'country') {
      tempData.country = text;
    } else if (id.includes('region.') && designation === 'state') {
      tempData.province = text;
    } else if (id.includes('subregion.')) {
      tempData.province = text;
    } else if (id.includes('county.') && designation === 'city') {
      tempData.city = text;  // 深圳市
    } else if (id.includes('joint_municipality.')) {
      tempData.jointMunicipality = text;  // 南山区/东城区
    } else if (id.includes('municipality.') && designation === 'suburb') {
      tempData.township = text;  // 粤海街道
    }
  });
  
  // 判断层级结构
  let city, district;
  if (tempData.city && tempData.jointMunicipality) {
    // 深圳：有county和joint_municipality
    city = tempData.city;      // 深圳市
    district = tempData.jointMunicipality;  // 南山区
  } else if (tempData.jointMunicipality && !tempData.city) {
    // 北京：只有joint_municipality
    city = tempData.jointMunicipality;  // 东城区
  } else {
    // 国外或其他情况
    city = tempData.city || '';
    district = tempData.jointMunicipality || '';
  }
  
  return { 
    country: tempData.country || '', 
    province: tempData.province || '', 
    city, 
    district, 
    township: tempData.township || '' 
  };
}
```

#### 3.2 自动翻译功能

```javascript
// 获取country_code
let countryCode = '';
context.forEach(item => {
  if (item.country_code) {
    countryCode = item.country_code;
  }
});

// 翻译国外地址
if (countryCode && countryCode.toLowerCase() !== 'cn') {
  country = getCountryTranslation(countryCode.toLowerCase());
  // United States → 美国
  
  if (province) {
    province = translateAddress(countryCode, province, 'province');
    // New York → 纽约州
  }
}
```

#### 3.3 翻译映射表

```javascript
// backend/routes/geocode-translations.js
const translations = {
  country: {
    'us': '美国', 'jp': '日本', 'fr': '法国', 'gb': '英国',
    'de': '德国', 'au': '澳大利亚', 'br': '巴西', 'in': '印度'
  },
  usStates: {
    'New York': '纽约州',
    'California': '加利福尼亚州',
    'Texas': '德克萨斯州'
  },
  ukRegions: {
    'England': '英格兰',
    'Scotland': '苏格兰'
  },
  jpRegions: {
    '東京都': '东京都',
    '大阪府': '大阪府'
  }
};
```

### 4. API接口设计

#### Endpoint
```
POST /api/geocode/reverse
```

#### Request
```json
{
  "latitude": 22.5431,
  "longitude": 113.9344
}
```

#### Response
```json
{
  "success": true,
  "data": {
    "country": "中国",
    "province": "广东省",
    "city": "深圳市",
    "district": "南山区",
    "township": "粤海街道",
    "formatted_address": "深大北天橋, 518060 粤海街道, 中国",
    "latitude": 22.5431,
    "longitude": 113.9344,
    "source": "maptiler"
  }
}
```

## 测试用例

### 国内地址

**1. 深圳（多层结构）**
```json
Request: { "latitude": 22.5431, "longitude": 113.9344 }
Response: {
  "country": "中国",
  "province": "广东省",
  "city": "深圳市",
  "district": "南山区",
  "township": "粤海街道"
}
```

**2. 北京（直辖市）**
```json
Request: { "latitude": 39.9042, "longitude": 116.4074 }
Response: {
  "country": "中国",
  "province": "北京市",
  "city": "东城区",
  "district": "",
  "township": "东华门街道"
}
```

### 国外地址（带翻译）

**3. 纽约（美国）**
```json
Request: { "latitude": 40.7128, "longitude": -74.0060 }
Response: {
  "country": "美国",
  "province": "纽约州",
  "city": "",
  "district": "Manhattan",
  "township": ""
}
```

**4. 伦敦（英国）**
```json
Request: { "latitude": 51.5074, "longitude": -0.1278 }
Response: {
  "country": "英国",
  "province": "英格兰",
  "city": "London",
  "district": "",
  "township": ""
}
```

**5. 东京（日本）**
```json
Request: { "latitude": 35.6762, "longitude": 139.6503 }
Response: {
  "country": "日本",
  "province": "东京都",
  "city": "",
  "district": "",
  "township": "和泉二丁目"
}
```

## 实现状态

### ✅ 已完成（M-4）

- [x] **API接口开发**：`POST /api/geocode/reverse`
- [x] **MapTiler集成**：统一使用MapTiler API
- [x] **层级解析逻辑**：处理3种不同结构（中国多层/直辖市/国外）
- [x] **自动翻译功能**：基于country_code的翻译映射
- [x] **翻译映射表**：30+国家，美国50州，英国/日本/澳大利亚
- [x] **数据库字段**：已添加township字段
- [x] **测试验证**：10个全球地点测试通过

### ⏳ 待开始

#### M-5：上传/编辑联动

**功能**：上传/编辑表单支持地图选点并自动回填地址

**实现方案**：
1. 在PhotoUpload/PhotoEdit表单中添加"地图选点"按钮
2. 点击后打开地图选点器（复用现有的MapLibre组件）
3. 用户点击地图后，自动调用`POST /api/geocode/reverse`
4. 获取解析结果后自动回填country/province/city/district/township字段
5. 用户可手动修改或确认

**技术要点**：
- 复用现有的`MapLibre.jsx`组件
- 地图选点后获取lat/lng
- 调用geocode API解析
- 更新表单状态

#### M-6：预览小地图

**功能**：PhotoPreview点击省市区字段显示400×300迷你地图

**实现方案**：
1. 在PhotoPreview中，省/市/区字段可点击
2. 点击后按需加载迷你MapLibre地图（400×300px）
3. 地图中心定位到照片的lat/lng
4. 显示marker标记当前位置
5. 显示formatted_address作为地图标注
6. 列表视图不加载小地图（性能优化）

**技术要点**：
- 使用`useState`控制地图的显示/隐藏
- 地图尺寸：400×300px（固定尺寸）
- 默认zoom：12（城市级别）
- 按需加载：避免初始渲染性能问题

## 数据库设计

### photos表字段

```sql
-- 已有字段
latitude REAL,
longitude REAL,
country TEXT,
province TEXT,
city TEXT,

-- 新增字段（M-4实现）
township TEXT  -- 街道/乡级

-- 保留字段
location_name TEXT  -- 具体地点名称（兼容旧数据）
```

### 使用建议

**显示时**：
```javascript
// 拼装完整中文地址
const fullAddress = [
  photo.country,
  photo.province,
  photo.city,
  photo.district,
  photo.township
].filter(Boolean).join('/');
// 输出：中国/广东省/深圳市/南山区/粤海街道
```

**搜索时**：
```javascript
// 可按任意字段搜索
WHERE province LIKE '%广东%' 
   OR city LIKE '%深圳%'
   OR district LIKE '%南山%'
```

## 关键技术点

### 1. MapTiler的context结构

```
ID格式说明：
- country.XXX → 国家
- region.XXX → 州/省（designation="state"）
- subregion.XXX → 州/省
- county.XXX → 市（designation="city"）
- joint_municipality.XXX → 区/市
- municipality.XXX → 街道（designation="suburb"）
- neighbourhood.XXX → 社区
```

### 2. 层级判断的关键

```javascript
// 判断关键：同时存在county和joint_municipality
if (tempData.city && tempData.jointMunicipality) {
  // 这是多层结构（深圳模式）
  city = tempData.city;        // 深圳市
  district = tempData.jointMunicipality;  // 南山区
} else if (tempData.jointMunicipality && !tempData.city) {
  // 这是直辖市结构（北京模式）
  city = tempData.jointMunicipality;  // 东城区
} else {
  // 国外或其他情况
  city = tempData.city || tempData.jointMunicipality || '';
  district = '';
}
```

### 3. 翻译时机

```javascript
// 在返回结果前应用翻译
if (countryCode && countryCode.toLowerCase() !== 'cn') {
  // 先判断字段是否已经是中文
  const needCountryTranslate = country && isLatinText(country);
  const needProvinceTranslate = province && isLatinText(province);

  if (needCountryTranslate) {
    country = getCountryTranslation(countryCode);
  }
  if (needProvinceTranslate) {
    province = translateAddress(countryCode, province);
  }
  // city/district/township 可按需扩展映射表或调用第三方翻译 API
}
```

## 注意事项

### ⚠️ 常见坑点

1. **context顺序是倒序**：从详细到宏观
2. **designation可能为空**：优先使用id前缀判断
3. **国外district经常为空**：可接受，保持city层级即可
4. **直辖市特殊处理**：需要特别判断

### ✅ 最佳实践

1. **先收集再判断**：使用tempData存储所有数据
2. **适配而非强制**：让代码适配API的数据结构
3. **统一接口**：避免国内/国外判断逻辑
4. **翻译策略**：优先使用原始中文；英文字段按 `country_code` 映射或调用备用翻译

## 扩展计划

### 近期（M-4 ~ M-6）

- [ ] 实现上传/批量上传流程的地图选点与地址解析
- [ ] 实现编辑页重新选点与字段回填
- [ ] 实现 PhotoPreview 按需加载的迷你地图（zoom=12）
- [ ] 添加坐标与地址字段校验（确保解析成功后再提交）
- [ ] 设计后台批量补录工具的雏形（为“未标点照片”留好入口）

### 中期

- [ ] 增加更多国家/地区的翻译
- [ ] 主要城市名的翻译（如Paris→巴黎）
- [ ] District层级的翻译优化
- [ ] 缓存机制优化（避免重复解析）
- [ ] `/map` 页面按照片坐标批量打点，必要时引入聚合或分级加载

### 长期

- [ ] 批量补全历史照片的地址字段
- [ ] 地址数据的统计和可视化
- [ ] 地理位置聚类功能

## 代码文件（拟新增）

- **后端（待创建）**：
  - `backend/routes/geocode.js` —— 地址解析 API（MapTiler 主体，预留 Geomaply 降级）
  - `backend/routes/geocode-translations.js` —— 国家/地区翻译映射表
  - `backend/index.js` —— 路由注册（新增 geocode 路由挂载）
  
- **前端（待改造）**：
  - `frontend/src/views/PhotoManagement.jsx` —— 上传/批量上传流程接入地图选点
  - `frontend/src/pages/PhotoDetail/index.jsx` —— 编辑页支持重新选点与回填
  - `frontend/src/components/PhotoPreview.jsx` —— 预览页按需加载迷你地图

- **测试（待创建）**：
  - `test-maptiler-global.js` —— 全球场景解析验证脚本
  - `test-geocode.js` —— 国内常见场景解析验证脚本

## 参考文档

- [MapTiler API文档](https://www.maptiler.com/api-documentation/)
- [知识库 - MapTiler地址解析经验](../docs/knowledge-base/problem-solving/MapTiler地址解析经验.md)
- [知识库 - 全球地址解析最佳实践](../docs/knowledge-base/best-practices/全球地址解析最佳实践.md)
