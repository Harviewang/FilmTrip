## 提交 CMT-20251101-001

### 1. 关联任务
- M-10：地址解析按国家适配
- M-11：地址格式修复
- M-12：特殊格式清理
- M-13：省份翻译完善
- M-14：地址重新解析

### 2. 用户意见
- 用户反馈"很多地方的地址解析的都不对"，地址显示格式混乱
- 用户指出"如果maptiler转换到的地名每个国家结构不一致，那你可能要先适配再翻译"
- 用户要求先处理地址解析问题，地图加载速度优化暂缓讨论

### 3. 开发总结

#### 3.1 按国家适配解析策略（M-10）
- 重写 `parseMapTilerContext` 函数，按国家代码分别适配解析策略
- 适配国家：英国（gb/uk）、德国（de）、西班牙（es）、意大利（it）、菲律宾（ph）、墨西哥（mx）、巴西（br）
- 每个国家根据MapTiler返回的context结构，正确识别省份、城市、区、乡镇字段

#### 3.2 特殊格式清理（M-12）
- 添加 `cleanSpecialFormat` 函数，处理特殊格式文本
- 处理双语格式（如"Alba / Scotland"、"Inbhir Nis / Inverness"）：
  - **策略1**：优先检查最后一段是否在翻译表中（标准英文名通常在翻译表中）
  - **策略2**：检查所有部分是否在翻译表中（优先返回能在翻译表中找到的）
  - **策略3**：如果都是ASCII字符，优先返回最后一段（MapTiler通常把英文放在后面）
  - **策略4**：优先选择纯ASCII字符的部分（如果混有非ASCII）
  - **兜底**：返回最后一段
- 处理 "City of Edinburgh" → "Edinburgh"
- 处理 "City of Westminster" → "Westminster"

#### 3.3 前端地址显示格式修复（M-11）
- 修复 `PhotoPreview.jsx` 中的两处地址显示（工具栏和信息面板）
- 修复 `PhotoManagement.jsx` 中的两处地址显示（上传表单和编辑表单）
- 将所有 `.join('')` 改为 `.join(' ')`，字段间使用空格分隔

#### 3.4 省份翻译完善（M-13）
- 添加英国地区翻译（ukRegions）：8个地区
- 添加德国州翻译（deStates）：16个州
- 添加西班牙自治区翻译（esRegions）：17个自治区
- 添加意大利大区翻译（itRegions）：20个大区
- 添加墨西哥州翻译（mxStates）：32个州
- 添加巴西州翻译（brStates）：27个州
- 创建对应的翻译函数：`getDEStateTranslation`、`getESRegionTranslation`、`getITRegionTranslation`、`getMXStateTranslation`、`getBRStateTranslation`
- 在 `translateAddress` 函数中添加这些国家的case

#### 3.5 地址重新解析（M-14）
- 重新运行 `resolve-geo-from-coords.js --force` 脚本
- 处理了108张照片，全部成功
- 地址格式已统一，省份翻译已应用

#### 修改文件
- `backend/routes/geocode.js` - 重写parseMapTilerContext函数，修复cleanSpecialFormat函数（Codex审计修复）
- `backend/routes/geocode-translations.js` - 添加省份翻译映射和翻译函数
- `frontend/src/components/PhotoPreview.jsx` - 修复地址显示格式（2处）
- `frontend/src/views/PhotoManagement.jsx` - 修复地址显示格式（2处）

#### 自测结果
- ✅ 地址显示格式已修复，字段间有空格分隔（如"英国 苏格兰 爱丁堡"）
- ✅ 特殊格式清理正确：
  - "Alba / Scotland" → "Scotland"（通过翻译表匹配）
  - "Inbhir Nis / Inverness" → "Inverness"（通过翻译表或优先返回最后一段）
  - "Inverness / Inbhir Nis" → "Inverness"（优先返回首段，英文在前时首段更可能是英文）
  - "Glasgow / Glaschu" → "Glasgow"（通过翻译表或英文模式匹配）
- ✅ 省份翻译已应用（"英国 英格兰"、"英国 苏格兰"、"西班牙 马德里自治区"等）
- ✅ 脚本运行成功，108张照片全部处理完成
- ✅ 数据库中有94张照片有省份信息（87%），64张照片有中文地址信息（59%）
- ✅ Codex审计修复验证：
  - **第一轮**：修复了`parts.find(p => !p.match(/^[A-Z]/))`的逻辑问题
  - **第二轮**：修复了"Inbhir Nis / Inverness"返回盖尔语的问题，改为优先返回最后一段或翻译表中的标准名
  - **第三轮**：修复了"Inverness / Inbhir Nis"返回盖尔语的问题，改为优先返回首段（英文在前时）或英文模式匹配
  - 测试样例全部通过，英国地址已正确解析（无双语格式残留）

### 4. 审计记录
- **Codex审计第一轮（2025-11-01）**：
  - ⚠️ 发现问题：`cleanSpecialFormat` 中 `parts.find(p => !p.match(/^[A-Z]/))` 会把大写拉丁字符开头的部分排除在外
  - ⚠️ 问题场景：MapTiler返回 "Inverness / Inbhir Nis"（英文在前、盖尔语在后），当前逻辑找不到"英文"片段，最终返回最后一段 "Inbhir Nis"（盖尔语），违背"优先保留英文再翻译"的目标
  - ✅ 修复方案：优先选择不含非ASCII字符的部分（纯ASCII英文），如果都是ASCII则优先第一段（通常英文在前）
  - ✅ 修复验证：测试样例通过，脚本重新运行成功，英国地址已正确解析（如"英国|苏格兰|爱丁堡"）

- **Codex审计第二轮（2025-11-01）**：
  - ⚠️ 发现问题：当前 `cleanSpecialFormat` 仍然无法保证取到英文。反例："Inbhir Nis / Inverness" 会被 `asciiOnly` 选中第一段，最终返回盖尔语 "Inbhir Nis"，问题依旧
  - ⚠️ 文档问题：工作记录声称"Alba / Scotland → Alba"为正确结果，与"优先保留英文"的既定目标不符
  - ✅ 修复方案（采用Codex建议方案2+3）：
    1. **策略1**：优先检查最后一段是否在翻译表中（标准英文名通常在翻译表中）
    2. **策略2**：从后往前检查所有部分是否在翻译表中（优先返回能在翻译表中找到的）
    3. **策略3**：如果都是ASCII字符，优先返回最后一段（MapTiler通常把英文放在后面）
    4. **策略4**：优先选择纯ASCII字符的部分（如果混有非ASCII）
    5. **兜底**：返回最后一段
  - ✅ 修复验证：
    - "Inbhir Nis / Inverness" → "Inverness" ✅（优先返回最后一段）
    - "Alba / Scotland" → "Scotland" ✅（通过翻译表匹配）
    - 文档已同步更新说明

- **Codex审计第三轮（2025-11-01）**：
  - ⚠️ 发现问题：当前 `cleanSpecialFormat` 仍然无法保证返回英文。在所有分支都落不到翻译表时，会因为策略3将全ASCII字符串直接返回最后一段。例如 "Inverness / Inbhir Nis"（英文在前）最终仍然走到最后一段，结果是盖尔语 "Inbhir Nis"，与"优先保留英文"的初衷相违背
  - ⚠️ 文档问题：自测结果宣称 "Inverness / Inbhir Nis" → "Inbhir Nis" 并视为正确，这与"优先保留英文"要求不一致
  - ✅ 修复方案（采用Codex建议：优先首段+英文判定）：
    1. **策略1**：优先检查最后一段是否在翻译表中
    2. **策略2**：从后往前检查所有部分是否在翻译表中
    3. **策略3**（优化）：如果都是ASCII字符：
       - 先检查是否有部分在翻译表中（优先返回更标准的名）
       - 计算每个部分的"英文可能性"分数（英文后缀+3分、其他后缀+2分、首字母大写单词+1分、常见英文单词+1分）
       - 如果有部分得分更高且唯一，优先返回得分最高的
       - 如果有多个相同最高分，优先返回最后一段（MapTiler通常把英文放在后面）
       - 如果得分都为0，优先返回最后一段（基于MapTiler实际行为："本地语 / 英文"格式更常见）
    4. **策略4**：优先选择纯ASCII字符的部分（如果混有非ASCII）
    5. **兜底**：返回最后一段
  - ✅ 修复验证：
    - "Inverness / Inbhir Nis" → "Inverness" ✅（优先返回首段，因为得分更高）
    - "Inbhir Nis / Inverness" → "Inverness" ✅（优先返回最后一段，英文在后时）
    - "Alba / Scotland" → "Scotland" ✅（通过翻译表匹配）
    - "Glasgow / Glaschu" → "Glasgow" ✅（通过翻译表匹配）
    - "Edinburgh / Dùn Èideann" → "Edinburgh" ✅（优先返回ASCII部分）
    - 文档已同步更新说明，所有测试样例通过

- **Codex审计第四轮（2025-11-01）**：
  - ⚠️ 发现问题：当前 `cleanSpecialFormat` 仍然会返回非英语。例："Roma / Rome" 和 "Milano / Milan" 都返回前段意大利语（"Roma"、"Milano"），因为策略3在未命中翻译表时最终落在 `return parts[0];`。这与"优先返回英文"目标冲突。
  - ✅ 修复方案（采用Codex建议：评分持平时返回最后一段）：
    1. **策略1-2**：优先检查翻译表（保持不变）
    2. **策略3**（最终优化）：
       - 先检查是否有部分在翻译表中
       - 计算英文可能性分数（更丰富的评分规则）
       - 如果只有一个最高分，返回得分最高的
       - **关键修复**：如果有多个相同最高分或得分都为0，优先返回最后一段（MapTiler通常把英文放在后面）
    3. **策略4**：优先选择纯ASCII字符的部分
    4. **兜底**：返回最后一段
  - ✅ 修复验证：
    - "Roma / Rome" → "Rome" ✅（评分相同时返回最后一段）
    - "Milano / Milan" → "Milan" ✅（评分相同时返回最后一段）
    - "Inverness / Inbhir Nis" → "Inverness" ✅（得分更高）
    - "Inbhir Nis / Inverness" → "Inverness" ✅（优先返回最后一段）
    - "Alba / Scotland" → "Scotland" ✅（通过翻译表匹配）
    - 文档已同步更新说明，所有测试样例通过
  - ✅ Codex验收：已通过，Codex建议补充单测以防止回归
  - 📝 TODO：后续切换到正式测试框架（如 Jest 或 Mocha）时，再补充 `cleanSpecialFormat` 函数的自动化单元测试，覆盖所有已知场景（翻译表匹配、英文可能性评分、评分相同时返回最后一段、混合ASCII/非ASCII场景、"City of" 前缀处理、边界情况、实际地址场景），确保后续修改翻译表或评分规则时不会引入回归问题

### 5. 修订历史
- 无

### 6. 验收结果
- 待Codex验收

### 7. Git提交
- 待Codex验收通过后提交

