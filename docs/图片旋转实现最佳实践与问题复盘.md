# 图片旋转实现最佳实践与问题复盘

## 📋 目录
- [问题背景](#问题背景)
- [常见错误实现](#常见错误实现)
- [业界最佳实践](#业界最佳实践)
- [问题复盘](#问题复盘)
- [解决方案](#解决方案)
- [代码示例](#代码示例)

## 🎯 问题背景

在实现图片预览功能时，图片旋转是一个常见需求。然而，很多实现都会遇到以下问题：

1. **"带着边一起转"**：图片旋转时，背景、阴影、边框等装饰元素也跟着旋转
2. **位置偏移**：旋转后图片位置不正确，出现靠下或溢出的情况
3. **尺寸计算错误**：旋转后图片尺寸不符合预期
4. **双重变换**：CSS和JavaScript中重复处理宽高交换

## ❌ 常见错误实现

### 错误1：容器旋转
```javascript
// ❌ 错误：整个容器都在旋转
<div 
  style={{
    transform: `rotate(${rotateDeg}deg)`, // 容器跟着转！
    width: `${cssWidth}px`,
    height: `${cssHeight}px`,
    backgroundColor: 'white',
    borderRadius: '8px',
    boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
  }}
>
  <img src="..." />
</div>
```

**问题**：用户看到的是整个白色背景容器跟着图片一起转

### 错误2：双重尺寸变换
```javascript
// ❌ 错误：双重变换
const rotatedAspect = rotateDeg % 180 === 90 ? 1 / imgAspect : imgAspect;
const rotatedIsPortrait = rotatedAspect < 1;

// getFittedSizeAfterRotate 内部已经处理了90/270度的宽高交换
const fittedSize = getFittedSizeAfterRotate(imgWidth, imgHeight, rotateDeg, viewMode);

// 但外层又做了一次轴交换
const cssWidth = Math.round(isSwappedAxis ? fittedSize.height : fittedSize.width);
const cssHeight = Math.round(isSwappedAxis ? fittedSize.width : fittedSize.height);
```

**问题**：导致尺寸计算错误，图片位置偏移

### 错误3：装饰元素跟着旋转
```javascript
// ❌ 错误：阴影边框跟着转
<img 
  style={{
    transform: `rotate(${rotateDeg}deg)`,
    boxShadow: '0 4px 8px rgba(0,0,0,0.1)', // 阴影跟着转！
    border: '1px solid #ccc', // 边框跟着转！
    borderRadius: '8px' // 圆角跟着转！
  }}
/>
```

## ✅ 业界最佳实践

### PhotoSwipe 的实现方式
```javascript
function rotateImage(angle) {
  const currentItem = this.currItem;
  const img = currentItem.container.querySelector('img');
  
  // 计算旋转后的尺寸
  const rotatedSize = this.getRotatedSize(currentItem, angle);
  
  // 应用旋转和尺寸
  img.style.transform = `rotate(${angle}deg)`;
  img.style.width = rotatedSize.width + 'px';
  img.style.height = rotatedSize.height + 'px';
  
  // 重新居中
  this.updateSize();
}

function getRotatedSize(item, angle) {
  const isRotated = angle % 180 !== 0;
  const w = isRotated ? item.h : item.w;
  const h = isRotated ? item.w : item.h;
  
  return { width: w, height: h };
}
```

### react-image-gallery 的实现方式
```javascript
const ImageGallery = ({ items, currentIndex }) => {
  const [rotation, setRotation] = useState(0);
  
  const handleRotate = () => {
    setRotation(prev => (prev + 90) % 360);
  };
  
  const getImageStyle = (item) => {
    const isRotated = rotation % 180 !== 0;
    const aspectRatio = isRotated ? item.height / item.width : item.width / item.height;
    
    return {
      transform: `rotate(${rotation}deg)`,
      transformOrigin: 'center center',
      maxWidth: '100%',
      maxHeight: '100%',
      objectFit: 'contain'
    };
  };
  
  return (
    <div className="image-gallery">
      <img 
        src={items[currentIndex].original}
        style={getImageStyle(items[currentIndex])}
        alt=""
      />
    </div>
  );
};
```

### lightGallery 的实现方式
```javascript
function rotateSlide(angle) {
  const slide = this.getSlide(this.index);
  const img = slide.querySelector('.lg-image');
  
  // 计算旋转后的尺寸
  const rotatedDimensions = this.getRotatedDimensions(slide, angle);
  
  // 应用变换
  img.style.transform = `rotate(${angle}deg)`;
  img.style.width = rotatedDimensions.width + 'px';
  img.style.height = rotatedDimensions.height + 'px';
  
  // 重新居中
  this.centerSlide(slide);
}

function getRotatedDimensions(slide, angle) {
  const naturalWidth = slide.dataset.width;
  const naturalHeight = slide.dataset.height;
  
  const isRotated = angle % 180 !== 0;
  const displayWidth = isRotated ? naturalHeight : naturalWidth;
  const displayHeight = isRotated ? naturalWidth : naturalHeight;
  
  // 计算适合容器的尺寸
  const containerWidth = this.container.clientWidth;
  const containerHeight = this.container.clientHeight;
  
  const scale = Math.min(
    containerWidth / displayWidth,
    containerHeight / displayHeight
  );
  
  return {
    width: displayWidth * scale,
    height: displayHeight * scale
  };
}
```

### Viewer.js 的实现方式
```javascript
function rotate(degree) {
  const image = this.image;
  const canvas = this.canvas;
  
  // 计算旋转后的尺寸
  const rotatedSize = this.getRotatedSize(degree);
  
  // 应用旋转
  image.style.transform = `rotate(${degree}deg)`;
  image.style.transformOrigin = 'center center';
  
  // 调整容器尺寸
  canvas.style.width = rotatedSize.width + 'px';
  canvas.style.height = rotatedSize.height + 'px';
  
  // 重新居中
  this.position();
}

function getRotatedSize(degree) {
  const isRotated = degree % 180 !== 0;
  const width = isRotated ? this.imageHeight : this.imageWidth;
  const height = isRotated ? this.imageWidth : this.imageHeight;
  
  return { width, height };
}
```

## 🔍 问题复盘

### 问题1：为什么会出现"带着边一起转"？

**根本原因**：
1. **容器旋转**：整个div容器在旋转，而不是只旋转图片
2. **背景色旋转**：白色背景跟着图片一起转
3. **装饰元素旋转**：阴影、边框、圆角等装饰元素跟着转

**错误代码**：
```javascript
// ❌ 容器跟着转
<div style={{ transform: `rotate(${rotateDeg}deg)` }}>
  <img src="..." />
</div>
```

### 问题2：为什么旋转后图片位置会偏移？

**根本原因**：
1. **双重尺寸变换**：`getFittedSizeAfterRotate` 内部已经处理了宽高交换，外层又做了一次交换
2. **容器尺寸不匹配**：CSS容器的尺寸与实际旋转后的图片尺寸不匹配
3. **居中计算错误**：旋转中心与容器中心不一致

**错误代码**：
```javascript
// ❌ 双重变换
const fittedSize = getFittedSizeAfterRotate(imgWidth, imgHeight, rotateDeg, viewMode);
const cssWidth = Math.round(isSwappedAxis ? fittedSize.height : fittedSize.width); // 又交换了一次！
const cssHeight = Math.round(isSwappedAxis ? fittedSize.width : fittedSize.height);
```

### 问题3：为什么尺寸计算会出错？

**根本原因**：
1. **假设尺寸**：使用固定的假设尺寸而不是真实的图片尺寸
2. **归一化错误**：使用归一化尺寸（1, 1/imgAspect）而不是像素尺寸
3. **旋转逻辑混乱**：90/270度的处理逻辑不一致

**错误代码**：
```javascript
// ❌ 使用假设尺寸
const imgWidth = 1200; // 假设宽度
const imgHeight = 1200 / imgAspect; // 假设高度
```

## 🛠️ 解决方案

### 核心原则
1. **只旋转图片，不旋转容器**
2. **使用真实的图片尺寸进行计算**
3. **避免双重尺寸变换**
4. **确保旋转中心与容器中心一致**
5. **装饰元素放在不旋转的容器上**

### 方案1：纯图片旋转
```javascript
// ✅ 正确：只有图片旋转，容器固定
<div 
  style={{
    width: '100%',
    height: '100%',
    display: 'grid',
    placeItems: 'center',
    backgroundColor: 'transparent' // 透明背景
  }}
>
  <img 
    src="..." 
    style={{
      transform: `rotate(${rotateDeg}deg)`,
      transformOrigin: 'center center',
      width: `${cssWidth}px`,
      height: `${cssHeight}px`,
      objectFit: 'contain'
      // 不要在这里加背景、阴影、边框
    }}
  />
</div>
```

### 方案2：分离旋转和装饰
```javascript
// ✅ 正确：装饰元素不旋转
<div 
  style={{
    width: '100%',
    height: '100%',
    display: 'grid',
    placeItems: 'center'
  }}
>
  {/* 装饰容器 - 不旋转 */}
  <div 
    style={{
      backgroundColor: 'white',
      borderRadius: '8px',
      boxShadow: '0 4px 8px rgba(0,0,0,0.1)',
      padding: '8px'
    }}
  >
    {/* 图片 - 只旋转这个 */}
    <img 
      src="..." 
      style={{
        transform: `rotate(${rotateDeg}deg)`,
        transformOrigin: 'center center',
        width: `${cssWidth}px`,
        height: `${cssHeight}px`,
        objectFit: 'contain'
      }}
    />
  </div>
</div>
```

## 📝 代码示例

### 完整的正确实现
```javascript
import React, { useState, useEffect, useCallback } from 'react';

const PhotoPreview = ({ photo, rotateDeg, viewMode = 'standard' }) => {
  const [imageDimensions, setImageDimensions] = useState({ width: 0, height: 0 });
  const [fittedSize, setFittedSize] = useState({ width: 0, height: 0 });

  // 计算适配尺寸
  const recomputeFittedSize = useCallback(() => {
    if (!photo || !imageDimensions.width || !imageDimensions.height) {
      setFittedSize({ width: 0, height: 0 });
      return;
    }

    const { width, height } = getFittedSizeAfterRotate(
      imageDimensions.width,
      imageDimensions.height,
      rotateDeg,
      viewMode
    );

    setFittedSize({
      width: Math.max(1, Math.round(width)),
      height: Math.max(1, Math.round(height))
    });
  }, [photo, imageDimensions.width, imageDimensions.height, rotateDeg, viewMode]);

  useEffect(() => {
    recomputeFittedSize();
  }, [recomputeFittedSize]);

  // 监听窗口大小变化
  useEffect(() => {
    const handleResize = () => {
      recomputeFittedSize();
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, [recomputeFittedSize]);

  return (
    <div 
      style={{
        width: '100%',
        height: '100%',
        display: 'grid',
        placeItems: 'center',
        backgroundColor: 'transparent'
      }}
    >
      <img
        src={photo.original}
        alt={photo.title || '照片'}
        style={{
          transform: `rotate(${rotateDeg}deg)`,
          transformOrigin: 'center center',
          width: `${fittedSize.width}px`,
          height: `${fittedSize.height}px`,
          objectFit: 'contain'
        }}
        onLoad={(e) => {
          const img = e.currentTarget;
          if (img && img.naturalWidth && img.naturalHeight) {
            setImageDimensions({ 
              width: img.naturalWidth, 
              height: img.naturalHeight 
            });
          }
        }}
      />
    </div>
  );
};

// 工具函数：计算旋转后的适配尺寸
function getFittedSizeAfterRotate(imgWidth, imgHeight, rotateDeg, viewMode = 'standard') {
  if (!imgWidth || !imgHeight) return { width: 0, height: 0 };

  // 规范角度到 [0,360)
  const norm = ((rotateDeg % 360) + 360) % 360;
  const swapped = norm === 90 || norm === 270;

  // 旋转后用于装箱的宽高
  const rw = swapped ? imgHeight : imgWidth;
  const rh = swapped ? imgWidth : imgHeight;
  const ar = rw / rh; // 旋转后宽高比

  // 目标比例：沉浸=100%，标准=80%
  const MAX_W_RATIO = viewMode === 'immersive' ? 1 : 0.8;
  const MAX_H_RATIO = viewMode === 'immersive' ? 1 : 0.8;

  const vw = window.innerWidth;
  const vh = window.innerHeight;

  const maxW = vw * MAX_W_RATIO;
  const maxH = vh * MAX_H_RATIO;

  let width, height;

  if (ar >= 1) {
    // 横向图（旋转后）
    width = Math.min(maxW, maxH * ar);
    height = width / ar;
    if (height > maxH) {
      height = maxH;
      width = height * ar;
    }
  } else {
    // 竖向图（旋转后）
    height = Math.min(maxH, maxW / ar);
    width = height * ar;
    if (width > maxW) {
      width = maxW;
      height = width / ar;
    }
  }

  return {
    width: Math.max(1, Math.floor(width)),
    height: Math.max(1, Math.floor(height)),
  };
}

export default PhotoPreview;
```

## 📚 总结

### 关键要点
1. **只旋转图片本身**，不要旋转容器
2. **使用真实的图片尺寸**进行计算
3. **避免双重尺寸变换**
4. **确保旋转中心正确**
5. **装饰元素放在不旋转的容器上**

### 避免的问题
- ❌ 容器跟着图片一起旋转
- ❌ 图片位置偏移或溢出
- ❌ 双重尺寸变换
- ❌ 旋转中心不正确
- ❌ 使用假设尺寸而不是真实尺寸

### 最佳实践
- ✅ 只旋转图片，容器保持固定
- ✅ 使用真实图片尺寸进行计算
- ✅ 一次性的尺寸变换
- ✅ 正确的旋转中心
- ✅ 分离旋转和装饰逻辑

通过遵循这些最佳实践，可以避免"带着边一起转"和位置偏移等问题，实现专业级的图片旋转功能。

## 🚨 Codex 修改问题分析

### 问题代码（第 301-308 行）
```javascript
// ❌ 错误：双重尺寸变换
const imageWidth = Math.max(
  1,
  Math.round(isRightAngle ? fittedSize.height : fittedSize.width)  // 又交换了一次！
);
const imageHeight = Math.max(
  1,
  Math.round(isRightAngle ? fittedSize.width : fittedSize.height)  // 又交换了一次！
);
```

### 问题分析
1. **双重变换**：`getFittedSizeAfterRotate` 函数内部已经处理了 90/270 度的宽高交换，但这里又根据 `isRightAngle` 做了一次交换
2. **容器跟着旋转**：容器使用了旋转后的尺寸，导致"带着边一起转"
3. **尺寸计算错误**：图片使用了错误的尺寸，导致显示异常

### 根本原因
没有理解 `getFittedSizeAfterRotate` 函数已经处理了旋转逻辑，在外层又重复处理了一次。

### 正确的修复方案

#### 方案1：移除双重变换
```javascript
// ✅ 正确：直接使用 fittedSize，不再做二次交换
const imageWidth = Math.max(1, Math.round(fittedSize.width));
const imageHeight = Math.max(1, Math.round(fittedSize.height));
```

#### 方案2：固定容器尺寸
```javascript
// ✅ 正确：容器使用固定尺寸，不跟着旋转
<div 
  className="relative transition-all duration-500 ease-out rounded-lg shadow-2xl overflow-hidden flex items-center justify-center"
  style={{
    width: '100%',        // 固定宽度
    height: '100%'       // 固定高度
  }}
>
```

#### 方案3：简化图片样式
```javascript
// ✅ 正确：图片使用计算后的正确尺寸
<img
  style={{
    width: `${imageWidth}px`,
    height: `${imageHeight}px`,
    objectFit: 'contain',
    transform: `rotate(${rotateDeg}deg)`,
    transformOrigin: 'center center',
    transition: shouldAnimateRotation ? 'transform 0.2s ease-out' : 'none'
  }}
/>
```

### 总结
Codex 的修改引入了双重尺寸变换和容器跟着旋转的问题，根本原因是没有理解 `getFittedSizeAfterRotate` 函数已经处理了旋转逻辑。正确的做法是移除外层的 `isRightAngle` 判断，直接使用 `fittedSize` 的宽高，并固定容器尺寸。

## 🌟 更多项目旋转实现示例

### 1. React Image Gallery 旋转实现
```javascript
import React, { useState } from 'react';
import ImageGallery from 'react-image-gallery';

const CustomImageGallery = ({ items }) => {
  const [rotations, setRotations] = useState({});

  const handleRotate = (index) => {
    setRotations(prev => ({
      ...prev,
      [index]: (prev[index] || 0) + 90
    }));
  };

  const renderItem = (item) => {
    const rotation = rotations[item.original] || 0;
    return (
      <div className="image-gallery-image">
        <img
          src={item.original}
          alt={item.description}
          style={{
            transform: `rotate(${rotation}deg)`,
            transformOrigin: 'center center',
            transition: 'transform 0.3s ease',
            maxWidth: '100%',
            maxHeight: '100%',
            objectFit: 'contain'
          }}
        />
        <button
          onClick={() => handleRotate(item.original)}
          className="rotate-btn"
          style={{
            position: 'absolute',
            top: '10px',
            right: '10px',
            background: 'rgba(0,0,0,0.7)',
            color: 'white',
            border: 'none',
            borderRadius: '4px',
            padding: '8px',
            cursor: 'pointer'
          }}
        >
          ↻
        </button>
      </div>
    );
  };

  return (
    <ImageGallery
      items={items}
      renderItem={renderItem}
      showThumbnails={false}
      showFullscreenButton={false}
      showPlayButton={false}
    />
  );
};
```

### 2. React Image Zoom 旋转实现
```javascript
import React, { useState } from 'react';
import ImageZoom from 'react-image-zoom';

const RotatableImageZoom = ({ src, alt }) => {
  const [rotation, setRotation] = useState(0);

  const handleRotate = () => {
    setRotation(prev => (prev + 90) % 360);
  };

  const imageProps = {
    src,
    alt,
    style: {
      transform: `rotate(${rotation}deg)`,
      transformOrigin: 'center center',
      transition: 'transform 0.3s ease',
      maxWidth: '100%',
      maxHeight: '100%'
    }
  };

  return (
    <div style={{ position: 'relative' }}>
      <ImageZoom {...imageProps} />
      <button
        onClick={handleRotate}
        style={{
          position: 'absolute',
          top: '10px',
          right: '10px',
          background: 'rgba(0,0,0,0.7)',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          padding: '8px',
          cursor: 'pointer'
        }}
      >
        ↻ 旋转
      </button>
    </div>
  );
};
```

### 3. React Image Lightbox 旋转实现
```javascript
import React, { useState } from 'react';
import Lightbox from 'react-image-lightbox';

const RotatableLightbox = ({ images, isOpen, onClose, photoIndex }) => {
  const [rotations, setRotations] = useState({});

  const handleRotate = () => {
    setRotations(prev => ({
      ...prev,
      [photoIndex]: (prev[photoIndex] || 0) + 90
    }));
  };

  const currentRotation = rotations[photoIndex] || 0;

  return (
    <>
      {isOpen && (
        <Lightbox
          mainSrc={images[photoIndex]}
          nextSrc={images[(photoIndex + 1) % images.length]}
          prevSrc={images[(photoIndex + images.length - 1) % images.length]}
          onCloseRequest={onClose}
          onMovePrevRequest={() => setPhotoIndex((photoIndex + images.length - 1) % images.length)}
          onMoveNextRequest={() => setPhotoIndex((photoIndex + 1) % images.length)}
          toolbarButtons={[
            <button
              key="rotate"
              onClick={handleRotate}
              style={{
                background: 'rgba(0,0,0,0.7)',
                color: 'white',
                border: 'none',
                borderRadius: '4px',
                padding: '8px 12px',
                cursor: 'pointer',
                marginRight: '10px'
              }}
            >
              ↻ 旋转
            </button>
          ]}
          imageTitle={`图片 ${photoIndex + 1} / ${images.length}`}
          imageCaption={`旋转角度: ${currentRotation}°`}
        />
      )}
    </>
  );
};
```

### 4. 原生 JavaScript 图片旋转实现
```javascript
class ImageRotator {
  constructor(containerId) {
    this.container = document.getElementById(containerId);
    this.rotation = 0;
    this.image = null;
    this.init();
  }

  init() {
    this.image = this.container.querySelector('img');
    this.createControls();
    this.bindEvents();
  }

  createControls() {
    const controls = document.createElement('div');
    controls.className = 'image-rotator-controls';
    controls.innerHTML = `
      <button class="rotate-left">↺ 左转</button>
      <button class="rotate-right">↻ 右转</button>
      <button class="reset-rotation">↻ 重置</button>
    `;
    this.container.appendChild(controls);
  }

  bindEvents() {
    const leftBtn = this.container.querySelector('.rotate-left');
    const rightBtn = this.container.querySelector('.rotate-right');
    const resetBtn = this.container.querySelector('.reset-rotation');

    leftBtn.addEventListener('click', () => this.rotate(-90));
    rightBtn.addEventListener('click', () => this.rotate(90));
    resetBtn.addEventListener('click', () => this.reset());
  }

  rotate(degrees) {
    this.rotation += degrees;
    this.applyRotation();
  }

  reset() {
    this.rotation = 0;
    this.applyRotation();
  }

  applyRotation() {
    if (this.image) {
      this.image.style.transform = `rotate(${this.rotation}deg)`;
      this.image.style.transformOrigin = 'center center';
      this.image.style.transition = 'transform 0.3s ease';
    }
  }
}

// 使用示例
const rotator = new ImageRotator('image-container');
```

### 5. Vue.js 图片旋转实现
```vue
<template>
  <div class="image-rotator">
    <div class="image-container">
      <img
        :src="imageSrc"
        :alt="imageAlt"
        :style="imageStyle"
        @load="onImageLoad"
      />
    </div>
    <div class="controls">
      <button @click="rotateLeft">↺ 左转</button>
      <button @click="rotateRight">↻ 右转</button>
      <button @click="resetRotation">↻ 重置</button>
    </div>
  </div>
</template>

<script>
export default {
  name: 'ImageRotator',
  props: {
    imageSrc: String,
    imageAlt: String
  },
  data() {
    return {
      rotation: 0,
      imageLoaded: false
    };
  },
  computed: {
    imageStyle() {
      return {
        transform: `rotate(${this.rotation}deg)`,
        transformOrigin: 'center center',
        transition: 'transform 0.3s ease',
        maxWidth: '100%',
        maxHeight: '100%',
        objectFit: 'contain'
      };
    }
  },
  methods: {
    rotateLeft() {
      this.rotation -= 90;
    },
    rotateRight() {
      this.rotation += 90;
    },
    resetRotation() {
      this.rotation = 0;
    },
    onImageLoad() {
      this.imageLoaded = true;
    }
  }
};
</script>

<style scoped>
.image-rotator {
  position: relative;
  display: inline-block;
}

.image-container {
  position: relative;
  overflow: hidden;
}

.controls {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  gap: 5px;
}

.controls button {
  background: rgba(0, 0, 0, 0.7);
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 12px;
  cursor: pointer;
  font-size: 12px;
}

.controls button:hover {
  background: rgba(0, 0, 0, 0.9);
}
</style>
```

### 6. Angular 图片旋转实现
```typescript
import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-image-rotator',
  template: `
    <div class="image-rotator">
      <div class="image-container">
        <img
          [src]="imageSrc"
          [alt]="imageAlt"
          [style.transform]="'rotate(' + rotation + 'deg)'"
          [style.transform-origin]="'center center'"
          [style.transition]="'transform 0.3s ease'"
          (load)="onImageLoad()"
        />
      </div>
      <div class="controls">
        <button (click)="rotateLeft()">↺ 左转</button>
        <button (click)="rotateRight()">↻ 右转</button>
        <button (click)="resetRotation()">↻ 重置</button>
      </div>
    </div>
  `,
  styles: [`
    .image-rotator {
      position: relative;
      display: inline-block;
    }
    
    .image-container {
      position: relative;
      overflow: hidden;
    }
    
    .controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
    }
    
    .controls button {
      background: rgba(0, 0, 0, 0.7);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 8px 12px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .controls button:hover {
      background: rgba(0, 0, 0, 0.9);
    }
  `]
})
export class ImageRotatorComponent implements OnInit {
  @Input() imageSrc: string = '';
  @Input() imageAlt: string = '';
  
  rotation: number = 0;
  imageLoaded: boolean = false;

  ngOnInit() {}

  rotateLeft() {
    this.rotation -= 90;
  }

  rotateRight() {
    this.rotation += 90;
  }

  resetRotation() {
    this.rotation = 0;
  }

  onImageLoad() {
    this.imageLoaded = true;
  }
}
```

### 7. CSS 纯样式旋转实现
```css
/* 基础旋转样式 */
.rotatable-image {
  transition: transform 0.3s ease;
  transform-origin: center center;
}

/* 旋转状态类 */
.rotate-90 { transform: rotate(90deg); }
.rotate-180 { transform: rotate(180deg); }
.rotate-270 { transform: rotate(270deg); }

/* 悬停效果 */
.rotatable-image:hover {
  transform: scale(1.05);
}

/* 动画关键帧 */
@keyframes rotate {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.rotating-image {
  animation: rotate 2s linear infinite;
}

/* 3D 旋转效果 */
.image-3d {
  transform-style: preserve-3d;
  transition: transform 0.5s ease;
}

.image-3d:hover {
  transform: rotateY(180deg);
}
```

### 8. 移动端触摸旋转实现
```javascript
class TouchImageRotator {
  constructor(element) {
    this.element = element;
    this.rotation = 0;
    this.lastTouchAngle = 0;
    this.isRotating = false;
    this.init();
  }

  init() {
    this.element.addEventListener('touchstart', this.handleTouchStart.bind(this));
    this.element.addEventListener('touchmove', this.handleTouchMove.bind(this));
    this.element.addEventListener('touchend', this.handleTouchEnd.bind(this));
  }

  handleTouchStart(e) {
    if (e.touches.length === 2) {
      this.isRotating = true;
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      this.lastTouchAngle = this.getAngle(touch1, touch2);
    }
  }

  handleTouchMove(e) {
    if (this.isRotating && e.touches.length === 2) {
      e.preventDefault();
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const currentAngle = this.getAngle(touch1, touch2);
      const angleDiff = currentAngle - this.lastTouchAngle;
      
      this.rotation += angleDiff;
      this.applyRotation();
      
      this.lastTouchAngle = currentAngle;
    }
  }

  handleTouchEnd(e) {
    this.isRotating = false;
  }

  getAngle(touch1, touch2) {
    const dx = touch2.clientX - touch1.clientX;
    const dy = touch2.clientY - touch1.clientY;
    return Math.atan2(dy, dx) * 180 / Math.PI;
  }

  applyRotation() {
    this.element.style.transform = `rotate(${this.rotation}deg)`;
    this.element.style.transformOrigin = 'center center';
  }
}

// 使用示例
const imageElement = document.querySelector('.rotatable-image');
const rotator = new TouchImageRotator(imageElement);
```

### 9. 服务端图片旋转实现 (Node.js + Sharp)
```javascript
const sharp = require('sharp');
const path = require('path');

class ImageRotationService {
  static async rotateImage(inputPath, outputPath, degrees) {
    try {
      await sharp(inputPath)
        .rotate(degrees)
        .jpeg({ quality: 90 })
        .toFile(outputPath);
      
      console.log(`图片旋转完成: ${outputPath}`);
      return outputPath;
    } catch (error) {
      console.error('图片旋转失败:', error);
      throw error;
    }
  }

  static async rotateImageBuffer(buffer, degrees) {
    try {
      const rotatedBuffer = await sharp(buffer)
        .rotate(degrees)
        .jpeg({ quality: 90 })
        .toBuffer();
      
      return rotatedBuffer;
    } catch (error) {
      console.error('图片旋转失败:', error);
      throw error;
    }
  }
}

// 使用示例
const inputPath = './input.jpg';
const outputPath = './output.jpg';
const degrees = 90;

ImageRotationService.rotateImage(inputPath, outputPath, degrees)
  .then(result => console.log('旋转完成:', result))
  .catch(error => console.error('旋转失败:', error));
```

### 10. 完整的 React Hook 旋转实现
```javascript
import { useState, useCallback, useRef, useEffect } from 'react';

const useImageRotation = (initialRotation = 0) => {
  const [rotation, setRotation] = useState(initialRotation);
  const [isAnimating, setIsAnimating] = useState(false);
  const imageRef = useRef(null);

  const rotate = useCallback((degrees) => {
    setIsAnimating(true);
    setRotation(prev => prev + degrees);
  }, []);

  const rotateLeft = useCallback(() => rotate(-90), [rotate]);
  const rotateRight = useCallback(() => rotate(90), [rotate]);
  const reset = useCallback(() => {
    setIsAnimating(true);
    setRotation(0);
  }, []);

  const onTransitionEnd = useCallback(() => {
    setIsAnimating(false);
  }, []);

  useEffect(() => {
    if (imageRef.current) {
      imageRef.current.style.transform = `rotate(${rotation}deg)`;
      imageRef.current.style.transformOrigin = 'center center';
      imageRef.current.style.transition = isAnimating ? 'transform 0.3s ease' : 'none';
    }
  }, [rotation, isAnimating]);

  return {
    rotation,
    isAnimating,
    imageRef,
    rotateLeft,
    rotateRight,
    reset,
    onTransitionEnd
  };
};

// 使用示例
const ImageComponent = ({ src, alt }) => {
  const {
    rotation,
    isAnimating,
    imageRef,
    rotateLeft,
    rotateRight,
    reset,
    onTransitionEnd
  } = useImageRotation();

  return (
    <div className="image-container">
      <img
        ref={imageRef}
        src={src}
        alt={alt}
        onTransitionEnd={onTransitionEnd}
      />
      <div className="controls">
        <button onClick={rotateLeft}>↺ 左转</button>
        <button onClick={rotateRight}>↻ 右转</button>
        <button onClick={reset}>↻ 重置</button>
      </div>
    </div>
  );
};
```

这些示例涵盖了不同框架和场景下的图片旋转实现，可以作为参考和学习的材料。

## 🚨 Codex 最新修改问题分析（第二次）

### 问题代码（第 416-419 行）
```javascript
// ❌ 错误：容器使用旋转后的尺寸
style={{
  width: `${stageWidth}px`,    // 容器跟着旋转！
  height: `${stageHeight}px`   // 容器跟着旋转！
}}
```

### 问题分析
1. **容器跟着旋转**：`stageWidth` 和 `stageHeight` 是基于 `fittedSize` 计算的，而 `fittedSize` 是旋转后的尺寸
2. **图片尺寸错误**：图片使用了容器的尺寸，而不是计算后的正确尺寸
3. **尺寸计算混乱**：`stageWidth` 和 `stageHeight` 直接使用了 `fittedSize`，导致容器跟着旋转

### 根本原因
没有理解容器应该保持固定尺寸，只有图片本身才应该旋转和调整尺寸。

### 正确的修复方案

#### 方案1：固定容器尺寸
```javascript
// ✅ 正确：容器使用固定尺寸，不跟着旋转
<div 
  className="relative transition-all duration-500 ease-out rounded-lg shadow-2xl overflow-hidden flex items-center justify-center"
  style={{
    width: '100%',        // 固定宽度
    height: '100%'       // 固定高度
  }}
>
```

#### 方案2：图片使用计算后的正确尺寸
```javascript
// ✅ 正确：图片使用 fittedSize 的尺寸
<img
  style={{
    width: `${fittedSize.width}px`,
    height: `${fittedSize.height}px`,
    objectFit: 'contain',
    transform: `rotate(${rotateDeg}deg)`,
    transformOrigin: 'center center',
    transition: shouldAnimateRotation ? 'transform 0.2s ease-out' : 'none'
  }}
/>
```

#### 方案3：移除 stageWidth/stageHeight
```javascript
// ✅ 正确：直接使用 fittedSize，不需要 stageWidth/stageHeight
// 删除这两行：
// const stageWidth = Math.max(1, Math.round(fittedSize.width));
// const stageHeight = Math.max(1, Math.round(fittedSize.height));
```

### 总结
Codex 的第二次修改仍然存在"带着边一起转"的问题，根本原因是没有理解容器应该保持固定尺寸，只有图片本身才应该旋转和调整尺寸。正确的做法是容器使用固定尺寸，图片使用 `fittedSize` 的尺寸，并移除 `stageWidth` 和 `stageHeight` 变量。

## 🔍 Codex 第三次修改问题分析：旋转时的"框"

### 问题描述
用户反馈："旋转的时候会有一个框，虽然最终是正确的，但是旋转的过程中肉眼可见这个边框限制了图片"

### 问题分析

#### 1. `overflow: hidden` 的容器边界
**问题位置**：第 414 行
```javascript
// ❌ 错误：容器设置了 overflow: hidden
className={`relative transition-all duration-500 ease-out rounded-lg shadow-2xl overflow-hidden flex items-center justify-center`}
```

**问题分析**：
- 容器设置了 `overflow: hidden`
- 当图片旋转时，在动画过程中可能会暂时超出容器的边界
- 这个容器的边界就像一个"框"一样，裁剪掉超出部分

#### 2. 容器尺寸限制
**问题位置**：第 427-429 行
```javascript
// ❌ 错误：容器尺寸固定
style={{
  width: `${stageWidth}px`,    // 容器尺寸固定
  height: `${stageHeight}px`   // 容器尺寸固定
}}
```

**问题分析**：
- 容器使用了固定的 `stageWidth` 和 `stageHeight`
- 这些尺寸是基于旋转后的图片计算的
- 但在旋转动画过程中，图片可能会暂时超出这个固定容器的边界

#### 3. 双重尺寸变换
**问题位置**：第 301-308 行
```javascript
// ❌ 错误：双重尺寸变换
const imageWidth = Math.max(
  1,
  Math.round(isRightAngle ? fittedSize.height : fittedSize.width)  // 又交换了一次！
);
const imageHeight = Math.max(
  1,
  Math.round(isRightAngle ? fittedSize.width : fittedSize.height)  // 又交换了一次！
);
```

**问题分析**：
- `getFittedSizeAfterRotate` 内部已经处理了旋转
- 但这里又根据 `isRightAngle` 做了一次交换
- 这可能导致图片尺寸在动画过程中出现不一致

### 解决方案

#### 方案1：移除容器的 `overflow: hidden`
```javascript
// ✅ 正确：移除 overflow: hidden，让图片可以自由旋转
className={`relative transition-all duration-500 ease-out rounded-lg shadow-2xl flex items-center justify-center`}
```

#### 方案2：使用更大的容器尺寸
```javascript
// ✅ 正确：容器使用更大的尺寸，避免裁剪
const containerSize = Math.max(stageWidth, stageHeight) * 1.2; // 增加20%的缓冲
style={{
  width: `${containerSize}px`,
  height: `${containerSize}px`
}}
```

#### 方案3：移除双重尺寸变换
```javascript
// ✅ 正确：直接使用 fittedSize，不再做二次交换
const imageWidth = Math.max(1, Math.round(fittedSize.width));
const imageHeight = Math.max(1, Math.round(fittedSize.height));
```

#### 方案4：优化动画过渡
```javascript
// ✅ 正确：使用更平滑的动画
transition: shouldAnimateRotation ? 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' : 'none'
```

### 推荐的综合解决方案
```javascript
// 1. 移除 overflow: hidden
className={`relative transition-all duration-500 ease-out rounded-lg shadow-2xl flex items-center justify-center`}

// 2. 使用更大的容器尺寸
const containerSize = Math.max(fittedSize.width, fittedSize.height) * 1.2;
style={{
  width: `${containerSize}px`,
  height: `${containerSize}px`
}}

// 3. 直接使用 fittedSize
const imageWidth = Math.max(1, Math.round(fittedSize.width));
const imageHeight = Math.max(1, Math.round(fittedSize.height));

// 4. 优化动画
transition: shouldAnimateRotation ? 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)' : 'none'
```

### 总结
旋转时出现"框"的问题主要由 `overflow: hidden`、固定容器尺寸和双重尺寸变换造成。解决方案是移除 `overflow: hidden`，使用更大的容器尺寸，移除双重尺寸变换，并优化动画过渡效果。

## ⚠️ 移除 overflow: hidden 可能带来的问题

### 问题分析
移除 `overflow: hidden` 确实会带来一些问题：

#### 1. 视觉问题
```javascript
// ❌ 移除后的问题
className="... rounded-lg shadow-2xl ..."  // 没有 overflow: hidden

// 问题：
// - 阴影效果可能超出容器边界，看起来不完整
// - 圆角效果可能不完整，图片边角超出圆角边界
// - 整体视觉效果不一致
```

#### 2. 布局影响
```javascript
// ❌ 可能的问题
// - 图片超出容器可能遮挡其他UI元素
// - 导航按钮、工具栏可能被遮挡
// - 页面布局可能被破坏
```

#### 3. 交互问题
```javascript
// ❌ 可能的问题
// - 点击区域可能不准确
// - 其他元素的点击事件可能被影响
```

## 🛠️ 更好的解决方案：动态调整容器尺寸

### 方案1：保持 overflow: hidden，但动态调整容器尺寸（推荐）
```javascript
// ✅ 正确的做法
const calculateContainerSize = (fittedSize, rotateDeg) => {
  const radians = rotateDeg * (Math.PI / 180);
  const cos = Math.abs(Math.cos(radians));
  const sin = Math.abs(Math.sin(radians));
  
  // 计算旋转后需要的容器尺寸
  const containerWidth = fittedSize.width * cos + fittedSize.height * sin;
  const containerHeight = fittedSize.width * sin + fittedSize.height * cos;
  
  // 增加一些缓冲，确保图片完全显示
  const buffer = 20; // 20px 缓冲
  
  return {
    width: `${containerWidth + buffer}px`,
    height: `${containerHeight + buffer}px`
  };
};

// 使用
const containerSize = calculateContainerSize(fittedSize, rotateDeg);

<div 
  className="relative transition-all duration-500 ease-out rounded-lg shadow-2xl overflow-hidden flex items-center justify-center"
  style={containerSize}
>
  <img
    style={{
      width: `${fittedSize.width}px`,
      height: `${fittedSize.height}px`,
      transform: `rotate(${rotateDeg}deg)`,
      transformOrigin: 'center center'
    }}
  />
</div>
```

### 方案2：使用 overflow: visible 但限制在特定区域
```javascript
// ✅ 另一种做法
<div className="relative flex-1 grid place-items-center">
  <div 
    className="relative transition-all duration-500 ease-out rounded-lg shadow-2xl flex items-center justify-center"
    style={{
      width: `${fittedSize.width * 1.5}px`,  // 使用更大的容器
      height: `${fittedSize.height * 1.5}px`,
      overflow: 'visible'  // 允许溢出
    }}
  >
    <img
      style={{
        width: `${fittedSize.width}px`,
        height: `${fittedSize.height}px`,
        transform: `rotate(${rotateDeg}deg)`,
        transformOrigin: 'center center'
      }}
    />
  </div>
</div>
```

### 方案3：旋转时临时调整 overflow
```javascript
// ✅ 动态调整 overflow
const [isRotating, setIsRotating] = useState(false);

const handleRotate = () => {
  setIsRotating(true);
  setRotateDeg(prev => prev + 90);
  
  // 旋转完成后恢复 overflow: hidden
  setTimeout(() => {
    setIsRotating(false);
  }, 300); // 动画持续时间
};

<div 
  className={`relative transition-all duration-500 ease-out rounded-lg shadow-2xl flex items-center justify-center ${
    isRotating ? 'overflow-visible' : 'overflow-hidden'
  }`}
>
```

## 📋 推荐方案

推荐使用**方案1**，因为：

1. **保持视觉一致性**：维持 `overflow: hidden` 和圆角、阴影效果
2. **解决"框"问题**：动态调整容器尺寸，确保图片完全显示
3. **避免布局问题**：不会影响其他UI元素
4. **性能更好**：不需要频繁切换CSS属性

### 具体实现
```javascript
// 计算容器尺寸的函数
const getContainerSize = (fittedSize, rotateDeg) => {
  const radians = rotateDeg * (Math.PI / 180);
  const cos = Math.abs(Math.cos(radians));
  const sin = Math.abs(Math.sin(radians));
  
  const width = fittedSize.width * cos + fittedSize.height * sin;
  const height = fittedSize.width * sin + fittedSize.height * cos;
  
  return {
    width: `${width + 40}px`,  // 40px 缓冲
    height: `${height + 40}px`
  };
};

// 使用
const containerSize = getContainerSize(fittedSize, rotateDeg);
```

### 总结
移除 `overflow: hidden` 会带来视觉、布局和交互问题。更好的解决方案是保持 `overflow: hidden`，但动态调整容器尺寸来适应旋转后的图片，这样既能解决"框"的问题，又能保持整体的视觉效果和布局稳定性。

## 🎯 最终简化方案：回归本质需求

### 核心需求
经过多次尝试和讨论，最终明确了核心需求：
1. **图片可以旋转**：横竖旋转
2. **背景灰色固定**：不随图片旋转变化
3. **尺寸规则**：长边占显示区域 80%，短边自适应

### 问题根源
之前的实现把简单问题复杂化了：
- 装饰效果放在图片上，导致跟着旋转
- 容器尺寸动态变化，导致布局混乱
- 过度设计，引入不必要的复杂逻辑

### 最简解决方案

```javascript
// 1. 计算图片尺寸（getFittedSizeAfterRotate 已经处理了 80% 的逻辑）
const imageWidth = Math.max(1, Math.round(fittedSize.width));
const imageHeight = Math.max(1, Math.round(fittedSize.height));

// 2. 简单的容器结构
<div 
  className="relative flex-1 grid place-items-center"
  style={{
    paddingTop: symmetricPadding,
    paddingBottom: symmetricPadding
  }}
>
  {/* 灰色背景容器 - 固定不旋转 */}
  <div 
    className="relative rounded-lg shadow-2xl overflow-hidden bg-slate-100"
    style={{
      padding: '20px' // 给图片一些内边距
    }}
  >
    {/* 图片 - 只旋转图片本身 */}
    <img
      src={photo.size2048 || photo.size1024 || photo.original}
      style={{
        width: `${imageWidth}px`,
        height: `${imageHeight}px`,
        objectFit: 'contain',
        transform: `rotate(${rotateDeg}deg)`,
        transformOrigin: 'center center',
        transition: shouldAnimateRotation ? 'transform 0.2s ease-out' : 'none',
        display: 'block'
      }}
    />
  </div>
</div>
```

### 关键点

1. **外层容器**：
   - 灰色背景 `bg-slate-100`
   - 圆角 `rounded-lg`
   - 阴影 `shadow-2xl`
   - 溢出隐藏 `overflow-hidden`
   - **容器不旋转**

2. **图片**：
   - 只有 `transform: rotate()` 应用在图片上
   - 没有装饰效果（圆角、阴影都在容器上）
   - **只旋转图片本身**

3. **尺寸计算**：
   - `getFittedSizeAfterRotate` 已经处理了长边 80% 的逻辑
   - 不需要额外的动态容器尺寸计算

### 为什么这个方案有效

| 问题 | 解决方式 |
|------|---------|
| 圆角跟着旋转 | 圆角在容器上，容器不旋转 ✅ |
| 阴影跟着旋转 | 阴影在容器上，容器不旋转 ✅ |
| 背景跟着旋转 | 背景在容器上，容器不旋转 ✅ |
| 旋转时有"框" | 容器有适当内边距，图片有旋转空间 ✅ |
| 尺寸不对 | 直接使用 `fittedSize`，已经是 80% ✅ |

### 总结
回归本质需求，使用最简单的方案：
- 容器负责装饰（背景、圆角、阴影），不旋转
- 图片负责旋转，不带装饰
- 尺寸已经由 `getFittedSizeAfterRotate` 正确计算

这是最简单、最直接、最有效的解决方案。
